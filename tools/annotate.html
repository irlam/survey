<!-- File: tools/annotate.html - PDF annotate tool UI. -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <meta name="mobile-web-app-capable" content="yes" />
<title>Annotate PDF Tool</title>
<link rel="stylesheet" href="/assets/ui.css?v=20260204_1">
<style>
  /* touch/tap friendly UI helpers */
  button, input, select {
    min-height: 44px;
    min-width: 44px;
    font-size: 1.1em;
    border-radius: 6px;
  }
  button:active, .btn:active, .btnPrimary:active {
    filter: brightness(0.85);
    box-shadow: 0 0 0 2px #0ff inset;
  }
  .cropOverlay, .annotateOverlay, .splitOverlay, .mergeOverlay, .printOverlay { touch-action: none; }
  .toolsRow{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  #annotStage{position:relative;padding:12px}
  /* make the viewer stage wider and centered like main viewer */
  #annotStage{ max-width: calc(100% - 48px); margin: 0 auto; }
  #pdfCanvas{border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,.2);background:#f6f7f9;display:block;z-index:1}
  #annotCanvas{border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,.2);background:transparent;display:block;z-index:2; touch-action: none;}
  .toolBtn.active{outline:2px solid rgba(0,255,231,.2)}
  /* small loader */
  .loader{width:18px;height:18px;border:3px solid rgba(255,255,255,0.12);border-top-color:var(--neon);border-radius:50%;animation:spin 1s linear infinite;display:inline-block;vertical-align:middle;margin-left:8px}
  @keyframes spin{to{transform:rotate(360deg)}}

  /* Neon-style selects / inputs to match the buttons */
  select{
    background: linear-gradient(90deg, var(--neon), var(--neon2)) !important;
    color: #eaffff !important;
    border: none !important;
    padding: 6px 10px !important;
    border-radius: 8px !important;
    box-shadow: 0 8px 28px rgba(0,255,231,.12) !important;
    outline: none !important;
    -webkit-appearance: none !important;
    appearance: none !important;
    font-size: 14px !important;
    font-weight: 700;
  }
  input[type="number"], input[type="color"], input[type="file"] {
    background: linear-gradient(180deg,#04262a,#021617) !important;
    color: #e6fff9 !important;
    border: 1px solid rgba(0,255,231,0.12) !important;
    padding: 6px 10px !important;
    border-radius: 8px !important;
    box-shadow: 0 6px 18px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.02) !important;
    outline: none !important;
    -webkit-appearance: none !important;
    appearance: none !important;
    font-size: 14px !important;
  }
  select:focus, input[type="number"]:focus, input[type="color"]:focus { box-shadow: 0 0 12px rgba(0,255,231,0.15) !important; border-color: rgba(0,255,231,0.5) !important; }
  /* widen primary plan select to look nicer */
  #planSelect{ min-width:320px; max-width:100%; width:100%; }
  #iconSelect{ min-width:120px; }
  /* file input sits inside label; make it compact */
  #fileUploader{ padding:6px 8px; background:transparent; border:none; color:var(--text); }
  /* style file input button in WebKit/Blink */
  input[type=file]::-webkit-file-upload-button{ background: linear-gradient(90deg, var(--neon), var(--neon2)); color:#041013; border:none; padding:6px 10px; border-radius:8px; margin-right:8px; }
  /* style file input button in Firefox */
  input[type=file]::file-selector-button{ background: linear-gradient(90deg, var(--neon), var(--neon2)); color:#041013; border:none; padding:6px 10px; border-radius:8px; margin-right:8px; }
  /* hide default select arrow on WebKit and show our own via background-image if desired */
  select::-ms-expand{display:none}
  select::-webkit-inner-spin-button, select::-webkit-outer-spin-button{ -webkit-appearance:none; margin:0; }

  /* explicit neon select box style (chevron, padding) */
  .neonSelect{
    padding-right: 40px !important;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24'%3E%3Cpath fill='%2300FFE7' d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
    background-repeat: no-repeat !important;
    background-position: right 10px center !important;
    background-size: 18px 18px !important;
    -webkit-appearance: none !important;
    appearance: none !important;
  }

  /* Match button visuals for disabled/hover states */
  .neonSelect:hover{ box-shadow: 0 10px 22px rgba(0,255,231,0.06); }
  .neonSelect:disabled{ opacity:0.5; cursor:not-allowed }

  /* Custom select dropdown styles */
  .customSelect{ position:relative; display:inline-flex; flex-direction:column; width:100%; max-width:100%; }
  .customSelect .selectButton{ width:100%; text-align:left; background: linear-gradient(90deg, var(--neon), var(--neon2)); border:none; padding:10px 14px; color:#eaffff; font-weight:800; font-size:14px; cursor:pointer; border-radius:12px; box-shadow: 0 8px 28px rgba(0,255,231,.12); display:flex; align-items:center; justify-content:space-between; gap:10px; transition: box-shadow 0.18s ease, transform 0.12s ease; }
  .customSelect .selectButton .selectedLabel{ flex:1; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .customSelect .selectButton .chevron{ width:16px; height:16px; flex-shrink:0; display:inline-block; transform:rotate(0deg); transition:transform 0.14s ease; }
  .customSelect.isOpen .selectButton{ box-shadow: 0 10px 28px rgba(0,255,231,0.22); transform: translateY(1px); }
  .customSelect.isOpen .selectButton .chevron{ transform:rotate(180deg); }
  .customSelect .selectList{ display:none; position:absolute; left:0; top:calc(100% + 8px); min-width:200px; width:100%; max-height:320px; overflow:auto; background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.08)); border:1px solid rgba(0,255,231,0.12); box-shadow: 0 18px 36px rgba(0,0,0,0.55); border-radius:12px; z-index:9999; padding:8px; list-style:none; margin:0; backdrop-filter: blur(6px); }
  .customSelect .selectList.open{ display:block }
  .customSelect .selectList li{ padding:12px 14px; border-radius:8px; color:#eaffff !important; cursor:pointer; font-weight:700; }
  .customSelect .selectList li:hover{ background: linear-gradient(90deg, rgba(0,255,231,0.12), rgba(57,255,20,0.08)); color:#ffffff; font-weight:800; }
  .customSelect .selectList li[aria-selected="true"]{ background: linear-gradient(90deg, var(--neon), var(--neon2)); color:#041013; font-weight:900; }
  /* small styling for the page input */
  #pageInput{ width:80px; }
  /* layout for larger viewer with right-side controls */
  .annotLayout{ display:flex; gap:18px; align-items:flex-start; }
  .viewerCol{ flex:1 1 auto; min-width:0; }
  .controlsCol{ width:240px; display:flex; flex-direction:column; align-items:stretch; gap:12px; }
  .controlsCol .btn, .controlsCol .btnPrimary{ width:100%; min-width:0; }
  .controlBlock{ display:flex; flex-direction:column; gap:10px; }
  .controlRow{ display:flex; gap:8px; align-items:center; }
  .controlRow > *{ flex:1; }
  @media (max-width:1100px){ .controlsCol{ width:220px; } }
  @media (max-width:900px){ .annotLayout{ flex-direction:column; } .controlsCol{ width:100%; align-items:stretch } }
</style>
</head>
<body>
  <header class="topbar">
    <button onclick="history.back()" class="iconBtn" aria-label="Back">←</button>
    <div class="brand">Annotate PDF</div>
    <div style="margin-left:auto" class="muted">Add arrows, lines, icons & text, export or save as plan</div>
  </header>

  <main style="padding:14px;">
    <div class="card">
      <div class="toolsRow">
          <label style="flex:1">Select plan: 
            <div id="planSelect" class="neonSelect customSelect" role="combobox" aria-haspopup="listbox" aria-expanded="false" tabindex="0">
              <div class="selectButton" role="button" aria-label="Select plan" tabindex="0">
                <span class="selectedLabel">-- choose plan --</span>
                <span class="chevron">⌄</span>
              </div>
              <ul class="selectList" role="listbox" tabindex="-1"></ul>
            </div>
            <span id="annotLoader" class="loader" style="display:none"></span>
          </label>
      </div>

      <div class="toolsRow" style="margin-bottom:12px;">
        <div style="display:flex;gap:6px;">
          <button class="btn toolBtn" id="tool_select" data-tool="select">Select</button>
          <button class="btn toolBtn" id="tool_line" data-tool="line">Line</button>
          <button class="btn toolBtn" id="tool_arrow" data-tool="arrow">Arrow</button>
          <button class="btn toolBtn" id="tool_rect" data-tool="rect">Rect</button>
          <button class="btn toolBtn" id="tool_free" data-tool="free">Freehand</button>
          <button class="btn toolBtn" id="tool_cloud" data-tool="cloud">Cloud</button>
          <button class="btn toolBtn" id="tool_text" data-tool="text">Text</button>
          <button class="btn toolBtn" id="tool_icon" data-tool="icon">Icon</button>
          <div id="iconSelect" class="neonSelect customSelect" role="combobox" aria-haspopup="listbox" aria-expanded="false" tabindex="0" style="width:120px">
            <div class="selectButton" role="button" tabindex="0" aria-label="Select icon">
              <span class="selectedLabel">Star</span>
              <span class="chevron">⌄</span>
            </div>
            <ul class="selectList" role="listbox" tabindex="-1">
              <li role="option" data-value="circle">Circle</li>
              <li role="option" data-value="square">Square</li>
              <li role="option" data-value="star" aria-selected="true">Star</li>
              <li role="option" data-value="checkmark">Check</li>
              <li role="option" data-value="arrow">Arrow</li>
              <li role="option" data-value="pin">Pin</li>
              <li role="option" data-value="flag">Flag</li>
            </ul>
          </div>
          <div style="display:flex;align-items:center;gap:6px;margin-left:8px;">
            <label class="muted">Color</label>
            <input type="color" id="colorPicker" value="#ff0000">
            <label class="muted">Width</label>
            <input id="strokeWidth" type="number" min="1" max="24" value="3" style="width:60px">
          </div>
        </div>
      </div>

      <div class="annotLayout">
        <div class="viewerCol">
          <div id="annotStage">
            <canvas id="pdfCanvas"></canvas>
            <canvas id="annotCanvas" style="position:absolute;left:0;top:0"></canvas>
          </div>
        </div>
        <aside class="controlsCol">
          <div class="controlBlock">
            <label>Or upload PDF:
              <input id="fileUploader" type="file" accept="application/pdf">
            </label>
            <div class="controlRow">
              <label class="muted" style="flex:0 0 auto">Page:</label>
              <input id="pageInput" type="number" min="1" value="1" style="width:80px">
            </div>
            <button id="btnUndo" class="btn">Undo</button>
            <button id="btnClear" class="btn">Clear</button>
            <button class="btn" id="btnExport">Export PDF</button>
            <button class="btnPrimary" id="btnSavePlan">Save as Plan</button>
          </div>
        </aside>
      </div>
      <div id="annotOut" class="muted" style="margin-top:8px"></div>
    </div>
  </main>

<script src="/vendor/pdfjs/pdf.min.js"></script>
<script src="/vendor/pdfjs/pdf-lib.min.js"></script>
<script>
  // ensure pdfjsLib is available (some builds attach to window)
  if (typeof pdfjsLib === 'undefined' && window && window.pdfjsLib) {
    pdfjsLib = window.pdfjsLib;
  }
  if (typeof pdfjsLib === 'undefined') {
    console.error('PDF.js not found at /vendor/pdfjs/pdf.min.js');
    document.getElementById('annotOut').textContent = 'PDF.js not loaded; check /vendor/pdfjs/pdf.min.js';
  } else {
    pdfjsLib.GlobalWorkerOptions.workerSrc = '/vendor/pdfjs/pdf.worker.min.js';
  }
  const planSelect = document.getElementById('planSelect');
  const fileUploader = document.getElementById('fileUploader');
  const btnLoad = document.getElementById('btnLoad');
  const canvas = document.getElementById('pdfCanvas');
  const aCanvas = document.getElementById('annotCanvas');
  const aCtx = aCanvas.getContext('2d');
  const ctx = canvas.getContext('2d');
  const out = document.getElementById('annotOut');
  let pdfBytes = null, pdfDoc = null, curPage = 1, totalPages = 0, pageViewport=null;
  let tool = 'select';
  let color = '#ff0000', stroke = 3;
  let shapes = []; // undo stack
  let current = null; // current drawing
  let selectedIndex = -1;
  let dragMode = null; // 'move' | 'rotate' | 'scale'
  let dragStart = null;

  async function loadPlans(){
    const r = await fetch('/api/list_plans.php');
    const j = await r.json();
    const list = planSelect.querySelector('.selectList');
    list.innerHTML = '<li role="option" data-value="">-- choose plan --</li>';
    const placeholderLi = list.querySelector('li[data-value=""]');
    if(placeholderLi){
      placeholderLi.onclick = ()=> selectCustomOption(planSelect, '', placeholderLi.textContent, '');
    }
    if(j.ok){
      for(const p of j.plans){
        const li = document.createElement('li');
        li.setAttribute('role','option');
        li.dataset.value = p.id;
        li.dataset.file = p.file_path||'';
        li.textContent = `${p.name||'Plan #'+p.id} (#${p.id})`;
        li.onclick = ()=>{ selectCustomOption(planSelect, p.id, li.textContent, p.file_path||''); };
        list.appendChild(li);
      }
    }
    // wire click open/close
    initCustomSelect(planSelect);
  }

  function selectCustomOption(wrapper, value, label, filePath){
    wrapper.querySelector('.selectedLabel').textContent = label;
    wrapper.value = value;
    wrapper.dataset.value = value;
    if(filePath){ wrapper.dataset.file = filePath; } else { delete wrapper.dataset.file; }
    wrapper.querySelector('.selectList').classList.remove('open');
    wrapper.classList.remove('isOpen');
    wrapper.setAttribute('aria-expanded','false');
    // mark aria-selected
    wrapper.querySelectorAll('.selectList li').forEach(li=> li.setAttribute('aria-selected', li.dataset.value==value ? 'true' : 'false'));
    // emit change event
    wrapper.dispatchEvent(new Event('change'));
  }

  function initCustomSelect(wrapper){
    const btn = wrapper.querySelector('.selectButton');
    const list = wrapper.querySelector('.selectList');
    // initialize selected item; prefer placeholder if nothing is pre-selected
    const preSelected = list.querySelector('li[aria-selected="true"]');
    const placeholder = list.querySelector('li[data-value=""]');
    const firstOption = list.querySelector('li[data-value]:not([data-value=""])');
    const initial = preSelected || placeholder || firstOption || list.querySelector('li');
    if(initial){
      wrapper.querySelector('.selectedLabel').textContent = initial.textContent;
      wrapper.value = initial.dataset.value || '';
      wrapper.dataset.value = wrapper.value;
      if(initial.dataset.file){ wrapper.dataset.file = initial.dataset.file; } else { delete wrapper.dataset.file; }
      list.querySelectorAll('li').forEach(li=> li.setAttribute('aria-selected', li === initial ? 'true' : 'false'));
    }

    const setOpen = (open)=>{
      list.classList.toggle('open', open);
      wrapper.classList.toggle('isOpen', open);
      wrapper.setAttribute('aria-expanded', open ? 'true' : 'false');
      if(open) list.focus();
    };

    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      setOpen(!list.classList.contains('open'));
    });
    btn.onclick = (e)=>{ e.preventDefault(); };
    wrapper.addEventListener('keydown', (e)=>{
      const items = Array.from(list.querySelectorAll('li'));
      const open = list.classList.contains('open');
      if(e.key === 'ArrowDown'){ e.preventDefault(); if(!open){ setOpen(true); } const next = items.find(li=> li.getAttribute('aria-selected')!=='true') || items[0]; next && next.focus(); }
      else if(e.key === 'ArrowUp'){ e.preventDefault(); if(!open){ setOpen(true); } items[items.length-1] && items[items.length-1].focus(); }
      else if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); if(!open){ setOpen(true); } else{ const focused = document.activeElement; if(focused && focused.parentElement===list){ const v = focused.dataset.value; selectCustomOption(wrapper, v, focused.textContent, focused.dataset.file||''); } } }
      else if(e.key === 'Escape'){ setOpen(false); }
    });
    // make list items tabbable/clickable
    list.querySelectorAll('li').forEach(li=>{
      li.tabIndex = 0;
      li.addEventListener('pointerdown', (e)=>{
        e.preventDefault();
        e.stopPropagation();
        selectCustomOption(wrapper, li.dataset.value, li.textContent, li.dataset.file||'');
      });
      li.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); selectCustomOption(wrapper, li.dataset.value, li.textContent, li.dataset.file||''); } });
    });
    // click outside to close
    document.addEventListener('pointerdown', (ev)=>{
      if(!wrapper.contains(ev.target)) {
        list.classList.remove('open');
        wrapper.classList.remove('isOpen');
        wrapper.setAttribute('aria-expanded','false');
      }
    });
    document.addEventListener('click', (ev)=>{ /* fallback */ if(!wrapper.contains(ev.target)) { list.classList.remove('open'); wrapper.classList.remove('isOpen'); wrapper.setAttribute('aria-expanded','false'); } });
  }
  function showAnnotLoader(){ try{ document.getElementById('annotLoader').style.display = 'inline-block'; }catch(e){} }
  function hideAnnotLoader(){ try{ document.getElementById('annotLoader').style.display = 'none'; }catch(e){} }

  planSelect.onchange = async ()=>{
    const id = planSelect.value; if(!id) return; showAnnotLoader();
    try{
      console.log('Loading plan id', id);
      const res = await fetch('/api/get_plan.php?plan_id=' + encodeURIComponent(id));
      const txt = await res.text(); let j;
      try{ j = JSON.parse(txt); }catch(err){ console.error('get_plan.php returned non-JSON', txt); throw new Error('Invalid JSON from get_plan'); }
      if(!res.ok || !j.ok) throw new Error(j.error || 'Failed to fetch plan info');
      const pdfUrl = j.pdf_url || (j.plan && (j.plan.file_path ? ('/storage/' + j.plan.file_path) : null));
      if(!pdfUrl) throw new Error('No PDF URL for plan');
      console.log('Fetching PDF URL:', pdfUrl);
      const r2 = await fetch(pdfUrl);
      console.log('PDF fetch response', r2.status, r2.headers.get('content-type'));
      if(!r2.ok) throw new Error('Failed to fetch PDF: HTTP ' + r2.status);
      const ab = await r2.arrayBuffer();
      await openPdfFromBytes(ab);
    }catch(e){ alert('Failed to load plan: '+e.message); out.textContent = 'Load failed: ' + e.message; console.error(e); }
    finally{ hideAnnotLoader(); }
  };
fileUploader.onchange = (e)=>{ const f=e.target.files&&e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=async ()=>{ pdfBytes=r.result; showAnnotLoader(); try{ await openPdfFromBytes(pdfBytes); }finally{ hideAnnotLoader(); } }; r.readAsArrayBuffer(f); };

  async function openPdfFromBytes(ab){ try{ pdfDoc = await pdfjsLib.getDocument({data:ab}).promise; totalPages = pdfDoc.numPages; document.getElementById('pageInput').max = totalPages; document.getElementById('pageInput').value = 1; curPage=1; await renderPage(curPage); }catch(e){ throw e; }finally{ hideAnnotLoader(); } }
  async function openPdfFromBytes(ab){
    try{
      console.log('openPdfFromBytes: creating PDF document');
      pdfDoc = await pdfjsLib.getDocument({data:ab}).promise;
      totalPages = pdfDoc.numPages;
      console.log('PDF loaded, totalPages=', totalPages);
      document.getElementById('pageInput').max = totalPages;
      document.getElementById('pageInput').value = 1;
      curPage=1;
      await renderPage(curPage);
    }catch(e){
      console.error('openPdfFromBytes error', e);
      throw e;
    }finally{ hideAnnotLoader(); }
  }
  async function renderPage(n){ if(!pdfDoc) return; const page = await pdfDoc.getPage(n); pageViewport = page.getViewport({scale:1}); const w = Math.min(pageViewport.width, 1200); const s = w / pageViewport.width; pageViewport = page.getViewport({scale:s}); canvas.width = Math.floor(pageViewport.width); canvas.height = Math.floor(pageViewport.height); canvas.style.width = canvas.width+'px'; canvas.style.height = canvas.height+'px'; aCanvas.width = canvas.width; aCanvas.height = canvas.height; aCanvas.style.left = canvas.offsetLeft+'px'; aCanvas.style.top = canvas.offsetTop+'px'; await page.render({canvasContext:ctx, viewport:pageViewport}).promise; redrawAnnotations(); }
  async function renderPage(n){
    if(!pdfDoc) return;
    try{
      console.log('renderPage: page=', n);
      const page = await pdfDoc.getPage(n);
      pageViewport = page.getViewport({scale:1});
      console.log('original viewport', {width: pageViewport.width, height: pageViewport.height});
      // calculate available width: prefer stage width, but fall back to a large portion of the window
      const stageEl = document.getElementById('annotStage');
      const stagePadding = 24; // allow some breathing room
      const fallback = Math.max(600, Math.floor(window.innerWidth * 0.72));
      const stageAvail = stageEl ? Math.max(320, stageEl.clientWidth - stagePadding) : 0;
      // Do NOT cap avail by the pageViewport.width here — we want to allow upscaling to fill the stage
      const avail = Math.max(stageAvail || 0, fallback);
        const originalWidth = pageViewport.width;
        const originalHeight = pageViewport.height;
        console.log('original viewport', {width: originalWidth, height: originalHeight});
        const desiredScale = Math.min(2.0, Math.max( (avail / originalWidth), 1 ));
        pageViewport = page.getViewport({scale: desiredScale});
        console.log('scaled viewport', {scale: desiredScale, width: pageViewport.width, height: pageViewport.height});
      canvas.width = Math.floor(pageViewport.width);
      canvas.height = Math.floor(pageViewport.height);
      // make canvas scale responsively to the stage width
      canvas.style.width = Math.min(canvas.width, (stageEl ? stageEl.clientWidth - 12 : canvas.width)) + 'px';
      canvas.style.height = canvas.height+'px';
      aCanvas.width = canvas.width;
      aCanvas.height = canvas.height;
      aCanvas.style.left = '0px';
      aCanvas.style.top = '0px';
      // match displayed CSS size so annotation overlay lines up when canvas is scaled
      aCanvas.style.width = canvas.style.width;
      aCanvas.style.height = canvas.style.height;
      // clear canvas so we can see if render leaves it blank
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#f6f7f9';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      try{
        const renderTask = page.render({canvasContext:ctx, viewport:pageViewport});
        await renderTask.promise;
        console.log('page.render completed');
      }catch(renderErr){
        console.error('page.render failed', renderErr);
        out.textContent = 'Render failed: ' + (renderErr && renderErr.message ? renderErr.message : String(renderErr));
      }
      redrawAnnotations();
    }catch(e){ console.error('renderPage error', e); out.textContent = 'Render error: '+(e.message||e); }
  }

  document.getElementById('pageInput').onchange = async (e)=>{ const v=parseInt(e.target.value||'1',10); if(v>=1 && v<=totalPages){ curPage=v; await renderPage(curPage); } };

  // tools
  document.querySelectorAll('.toolBtn').forEach(b=>{ b.onclick=()=>{ document.querySelectorAll('.toolBtn').forEach(x=>x.classList.remove('active')); b.classList.add('active'); tool=b.dataset.tool; selectedIndex = -1; dragMode=null; dragStart=null; redrawAnnotations(); }; });
  document.getElementById('colorPicker').addEventListener('input', (e)=>{ color=e.target.value; });
  document.getElementById('strokeWidth').addEventListener('change',(e)=>{ stroke=parseInt(e.target.value||3,10); });

  aCanvas.addEventListener('pointerdown',(e)=>{
    const r=aCanvas.getBoundingClientRect(); const scaleX = aCanvas.width / r.width; const scaleY = aCanvas.height / r.height; const x=(e.clientX-r.left) * scaleX; const y=(e.clientY-r.top) * scaleY;
    if(tool==='select'){
      const hit = hitTest(x,y);
      selectedIndex = hit.index;
      dragMode = hit.handle;
      if(hit.index>=0){
        const sh = shapes[hit.index];
        const bbox = getBoundingBox(sh);
        const cx = (bbox.x1+bbox.x2)/2, cy=(bbox.y1+bbox.y2)/2;
        dragStart = {x, y, shape: cloneShape(sh), rotation: sh.rotation||0, bbox, cx, cy, corner: hit.corner};
      } else {
        dragStart = null;
      }
      redrawAnnotations();
      try{ if(typeof e.pointerId !== 'undefined') aCanvas.setPointerCapture(e.pointerId); }catch(ignore){}
      return;
    }
    if(tool==='text'){
      const txt = prompt('Text to add');
      if(txt){ shapes.push({type:'text', x,y, text:txt, color, size:16}); redrawAnnotations(); }
      return;
    }
    current={tool, color, stroke, startX:x, startY:y, points: [{x,y}]};
    try{ if(typeof e.pointerId !== 'undefined') aCanvas.setPointerCapture(e.pointerId); }catch(ignore){}
  });
  aCanvas.addEventListener('pointermove',(e)=>{
    const r=aCanvas.getBoundingClientRect(); const scaleX = aCanvas.width / r.width; const scaleY = aCanvas.height / r.height; const x=(e.clientX-r.left) * scaleX; const y=(e.clientY-r.top) * scaleY;
    if(tool==='select'){
      if(selectedIndex<0 || !dragStart) return;
      const s = shapes[selectedIndex];
      const dx = x - dragStart.x;
      const dy = y - dragStart.y;
      if(dragMode==='rotate'){
        const a1 = Math.atan2(dragStart.y - dragStart.cy, dragStart.x - dragStart.cx);
        const a2 = Math.atan2(y - dragStart.cy, x - dragStart.cx);
        s.rotation = (dragStart.rotation||0) + (a2 - a1);
      } else if(dragMode==='scale'){
        const halfW = Math.max(4, (dragStart.bbox.x2 - dragStart.bbox.x1)/2);
        const halfH = Math.max(4, (dragStart.bbox.y2 - dragStart.bbox.y1)/2);
        const localX = x - dragStart.cx;
        const localY = y - dragStart.cy;
        const sx = Math.max(0.2, Math.min(5, Math.abs(localX) / halfW));
        const sy = Math.max(0.2, Math.min(5, Math.abs(localY) / halfH));
        const signX = dragStart.corner.includes('e') ? 1 : dragStart.corner.includes('w') ? -1 : Math.sign(localX)||1;
        const signY = dragStart.corner.includes('s') ? 1 : dragStart.corner.includes('n') ? -1 : Math.sign(localY)||1;
        scaleShapeAroundCenter(s, dragStart.shape, dragStart.cx, dragStart.cy, sx*signX, sy*signY);
      } else { // move
        applyDelta(s, dragStart.shape, dx, dy);
      }
      redrawAnnotations();
      return;
    }
    if(!current) return;
    const x2=x, y2=y;
    if(current.tool==='free'){ current.points.push({x:x2,y:y2}); drawTemp(); }
    else { current.endX=x2; current.endY=y2; drawTemp(); }
  });
  aCanvas.addEventListener('pointerup',(e)=>{
    if(tool==='select'){
      dragMode=null; dragStart=null;
      try{ aCanvas.releasePointerCapture(e.pointerId); }catch(ignore){}
      return;
    }
    if(!current) return;
    if(current.tool==='icon'){
      const id = document.getElementById('iconSelect').value;
      current.icon = id;
      current.size = 28;
    } else if(current.tool==='cloud'){
      current.type = 'cloud';
      current.stroke = current.stroke || stroke;
    }
    const saved = Object.assign({}, current);
    if(!saved.type && saved.tool) saved.type = saved.tool;
    shapes.push(saved);
    current=null;
    try{ aCanvas.releasePointerCapture(e.pointerId); }catch(ignore){}
    redrawAnnotations();
  });

  // handle pointer cancel (e.g., OS gesture cancel) similar to pointerup
  aCanvas.addEventListener('pointercancel', (e)=>{
    current = null; dragMode=null; dragStart=null;
    try{ aCanvas.releasePointerCapture(e.pointerId); }catch(ignore){}; redrawAnnotations();
  });

  function drawTemp(){
    redrawAnnotations();
    if(!current) return;
    const tempShape = Object.assign({}, current, {endX: current.endX ?? current.startX, endY: current.endY ?? current.startY, type: current.tool});
    drawShape(aCtx, tempShape, 1, false);
  }
  function drawArrowHead(ctx,x1,y1,x2,y2,w, color){ const dx=x2-x1, dy=y2-y1; const dist = Math.hypot(dx,dy); const ang=Math.atan2(dy,dx); const len = Math.min( Math.max(12, dist * 0.15), 40 ); // scale arrow head with line length
    ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(x2,y2); ctx.lineTo(x2 - len*Math.cos(ang - Math.PI/6), y2 - len*Math.sin(ang - Math.PI/6)); ctx.lineTo(x2 - len*Math.cos(ang + Math.PI/6), y2 - len*Math.sin(ang + Math.PI/6)); ctx.closePath(); ctx.fill(); }

  function drawIcon(ctx, type, x, y, size, color){ ctx.save(); ctx.fillStyle=color; ctx.strokeStyle=color; ctx.lineWidth=2; if(type==='pin'){ ctx.beginPath(); ctx.arc(x, y - size*0.25, size*0.35, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(x, y); ctx.quadraticCurveTo(x - size*0.4, y + size*0.6, x, y + size); ctx.quadraticCurveTo(x + size*0.4, y + size*0.6, x, y); ctx.fill(); } else if(type==='star'){ const spikes=5; const outer=size*0.5; const inner=outer*0.5; let rot=Math.PI/2*3; let cx=x; let cy=y; ctx.beginPath(); for(let i=0;i<spikes;i++){ let ox = cx + Math.cos(rot) * outer; let oy = cy + Math.sin(rot) * outer; ctx.lineTo(ox,oy); rot += Math.PI / spikes; ox = cx + Math.cos(rot) * inner; oy = cy + Math.sin(rot) * inner; ctx.lineTo(ox,oy); rot += Math.PI / spikes; } ctx.closePath(); ctx.fill(); } else if(type==='flag'){ ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + size*0.6, y - size*0.3); ctx.lineTo(x + size*0.6, y + size*0.3); ctx.closePath(); ctx.fill(); ctx.fillRect(x - size*0.05, y - size*0.6, size*0.1, size*1.2); } else if(type==='circle'){ ctx.beginPath(); ctx.arc(x, y, size*0.4, 0, Math.PI*2); ctx.fill(); } else if(type==='square'){ ctx.fillRect(x - size*0.4, y - size*0.4, size*0.8, size*0.8); } else if(type==='checkmark'){ ctx.beginPath(); ctx.moveTo(x - size*0.3, y); ctx.lineTo(x - size*0.1, y + size*0.2); ctx.lineTo(x + size*0.3, y - size*0.2); ctx.stroke(); } else if(type==='arrow'){ ctx.beginPath(); ctx.moveTo(x - size*0.4, y); ctx.lineTo(x + size*0.4, y); ctx.lineTo(x + size*0.2, y - size*0.2); ctx.moveTo(x + size*0.4, y); ctx.lineTo(x + size*0.2, y + size*0.2); ctx.stroke(); } ctx.restore(); }

function drawIconPreview(ctx, current){ const size = 24; drawIcon(ctx, document.getElementById('iconSelect').value, current.startX, current.startY, size, current.color); }

function redrawAnnotations(){
  aCtx.clearRect(0,0,aCanvas.width,aCanvas.height);
  shapes.forEach((s,idx)=> drawShape(aCtx, s, 1, idx===selectedIndex));
  drawSelectionOverlay();
}

function drawShape(ctx, s, scaleFactor=1, highlight=false){
  const rot = s.rotation || 0;
  const bbox = getBoundingBox(s);
  const cx = (bbox.x1 + bbox.x2)/2;
  const cy = (bbox.y1 + bbox.y2)/2;
  ctx.save();
  ctx.translate(cx, cy);
  if(rot) ctx.rotate(rot);
  ctx.strokeStyle = s.color;
  ctx.fillStyle = s.color;
  ctx.lineWidth = (s.stroke||s.size||3) * scaleFactor;
  const draw = ()=>{
    if(s.type==='free'){
      ctx.beginPath();
      const pts = s.points||[];
      if(pts.length){
        ctx.moveTo(pts[0].x - cx, pts[0].y - cy);
        for(let p of pts) ctx.lineTo(p.x - cx, p.y - cy);
      }
      ctx.stroke();
    } else if(s.type==='line'){
      ctx.beginPath();
      ctx.moveTo(s.startX - cx, s.startY - cy);
      ctx.lineTo(s.endX - cx, s.endY - cy);
      ctx.stroke();
    } else if(s.type==='arrow'){
      ctx.beginPath();
      ctx.moveTo(s.startX - cx, s.startY - cy);
      ctx.lineTo(s.endX - cx, s.endY - cy);
      ctx.stroke();
      drawArrowHead(ctx, s.startX - cx, s.startY - cy, s.endX - cx, s.endY - cy, (s.stroke||3)*scaleFactor, s.color);
    } else if(s.type==='rect'){
      ctx.strokeRect(Math.min(s.startX,s.endX) - cx, Math.min(s.startY,s.endY) - cy, Math.abs(s.endX-s.startX), Math.abs(s.endY-s.startY));
    } else if(s.type==='cloud'){
      drawCloud(ctx, s.startX - cx, s.startY - cy, (s.endX||s.startX) - cx, (s.endY||s.startY) - cy, (s.stroke||3)*scaleFactor, s.color);
    } else if(s.type==='text'){
      ctx.font=((s.size||16)*scaleFactor)+'px sans-serif';
      ctx.fillText(s.text, s.x - cx, s.y - cy);
    } else if(s.type==='icon'){
      drawIcon(ctx, s.icon, s.startX - cx, s.startY - cy, (s.size||24)*scaleFactor, s.color);
    }
  };
  draw();
  ctx.restore();
}

// Draw a fluffy cloud outline using repeating arcs around a bounding box
function drawCloud(ctx, x1, y1, x2, y2, strokeWidth, color){
  const left = Math.min(x1, x2), right = Math.max(x1, x2);
  const top = Math.min(y1, y2), bottom = Math.max(y1, y2);
  const w = Math.max(16, right - left);
  const h = Math.max(16, bottom - top);
  const radius = Math.max(8, Math.min(w, h) * 0.2);
  const bumpsX = Math.max(4, Math.round(w / (radius * 1.2)));
  const bumpsY = Math.max(3, Math.round(h / (radius * 1.2)));
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = strokeWidth;
  ctx.beginPath();
  // start at top-left
  ctx.moveTo(left, top + radius);
  // left side bumps
  for(let i=0;i<bumpsY;i++){
    const sy = top + (h/bumpsY)*i;
    const ey = top + (h/bumpsY)*(i+1);
    const my = (sy+ey)/2;
    ctx.quadraticCurveTo(left - radius, my, left, ey);
  }
  // bottom bumps
  for(let i=0;i<bumpsX;i++){
    const sx = left + (w/bumpsX)*i;
    const ex = left + (w/bumpsX)*(i+1);
    const mx = (sx+ex)/2;
    ctx.quadraticCurveTo(mx, bottom + radius, ex, bottom);
  }
  // right side bumps
  for(let i=0;i<bumpsY;i++){
    const sy = bottom - (h/bumpsY)*i;
    const ey = bottom - (h/bumpsY)*(i+1);
    const my = (sy+ey)/2;
    ctx.quadraticCurveTo(right + radius, my, right, ey);
  }
  // top bumps
  for(let i=0;i<bumpsX;i++){
    const sx = right - (w/bumpsX)*i;
    const ex = right - (w/bumpsX)*(i+1);
    const mx = (sx+ex)/2;
    ctx.quadraticCurveTo(mx, top - radius, ex, top);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function getBoundingBox(s){
  if(s.type==='text'){ const size=s.size||16; return {x1:s.x, y1:s.y-size, x2:s.x+size*5, y2:s.y+size}; }
  if(s.type==='icon'){ const sz=s.size||24; return {x1:s.startX - sz, y1:s.startY - sz, x2:s.startX + sz, y2:s.startY + sz}; }
  if(s.type==='free'){
    const xs=s.points.map(p=>p.x), ys=s.points.map(p=>p.y);
    return {x1:Math.min(...xs), y1:Math.min(...ys), x2:Math.max(...xs), y2:Math.max(...ys)};
  }
  const x1=Math.min(s.startX, s.endX||s.startX), x2=Math.max(s.startX, s.endX||s.startX);
  const y1=Math.min(s.startY, s.endY||s.startY), y2=Math.max(s.startY, s.endY||s.startY);
  return {x1, y1, x2, y2};
}

function getShapeCenter(s){ const b=getBoundingBox(s); return {cx:(b.x1+b.x2)/2, cy:(b.y1+b.y2)/2}; }

function drawSelectionOverlay(){
  if(selectedIndex<0 || selectedIndex>=shapes.length) return;
  const s = shapes[selectedIndex];
  const rot = s.rotation||0;
  const bbox = getBoundingBox(s);
  const cx = (bbox.x1+bbox.x2)/2;
  const cy = (bbox.y1+bbox.y2)/2;
  const w = bbox.x2 - bbox.x1;
  const h = bbox.y2 - bbox.y1;
  aCtx.save();
  aCtx.translate(cx, cy);
  if(rot) aCtx.rotate(rot);
  aCtx.strokeStyle = 'rgba(0,255,231,0.8)';
  aCtx.setLineDash([6,4]);
  aCtx.strokeRect(-w/2 -4, -h/2 -4, w+8, h+8);
  aCtx.setLineDash([]);
  // rotate handle above top edge
  const handleY = -h/2 - 24;
  aCtx.beginPath();
  aCtx.moveTo(0, -h/2 -4);
  aCtx.lineTo(0, handleY+8);
  aCtx.stroke();
  aCtx.beginPath();
  aCtx.fillStyle='rgba(0,255,231,0.9)';
  aCtx.strokeStyle='rgba(0,255,231,1)';
  aCtx.arc(0, handleY, 8, 0, Math.PI*2);
  aCtx.fill();
  // corner resize handles
  const handles = [
    {x:-w/2, y:-h/2, c:'nw'},
    {x:w/2, y:-h/2, c:'ne'},
    {x:w/2, y:h/2, c:'se'},
    {x:-w/2, y:h/2, c:'sw'},
  ];
  for(const hd of handles){
    aCtx.beginPath();
    aCtx.fillStyle='rgba(0,255,231,0.95)';
    aCtx.strokeStyle='rgba(0,255,231,1)';
    aCtx.rect(hd.x-6, hd.y-6, 12, 12);
    aCtx.fill();
    aCtx.stroke();
  }
  aCtx.restore();
}

function hitTest(x, y){
  for(let i=shapes.length-1;i>=0;i--){
    const s = shapes[i];
    const rot = s.rotation||0;
    const {cx, cy} = getShapeCenter(s);
    const dx = x - cx, dy = y - cy;
    const localX = Math.cos(-rot)*dx - Math.sin(-rot)*dy + cx;
    const localY = Math.sin(-rot)*dx + Math.cos(-rot)*dy + cy;
    const b = getBoundingBox(s);
    // rotate handle hit
    const handleY = b.y1 - 24;
    const distHandle = Math.hypot(localX - cx, localY - handleY);
    if(distHandle < 12) return {index:i, handle:'rotate', corner:null};
    // corner handles
    const corners = [
      {x:b.x1, y:b.y1, c:'nw'},
      {x:b.x2, y:b.y1, c:'ne'},
      {x:b.x2, y:b.y2, c:'se'},
      {x:b.x1, y:b.y2, c:'sw'},
    ];
    for(const c of corners){
      if(Math.abs(localX - c.x) <= 8 && Math.abs(localY - c.y) <= 8){
        return {index:i, handle:'scale', corner:c.c};
      }
    }
    if(localX>=b.x1 && localX<=b.x2 && localY>=b.y1 && localY<=b.y2){
      return {index:i, handle:'move', corner:null};
    }
  }
  return {index:-1, handle:null};
}

function cloneShape(s){ return JSON.parse(JSON.stringify(s)); }

function applyDelta(target, original, dx, dy){
  Object.assign(target, cloneShape(original));
  if(target.type==='free') target.points = original.points.map(p=>({x:p.x+dx, y:p.y+dy}));
  else if(target.type==='text'){ target.x = original.x + dx; target.y = original.y + dy; }
  else if(target.type==='icon'){ target.startX = original.startX + dx; target.startY = original.startY + dy; }
  else { target.startX = original.startX + dx; target.startY = original.startY + dy; target.endX = (original.endX||original.startX) + dx; target.endY = (original.endY||original.startY) + dy; }
}

function scaleShape(s, factor){
  const c = cloneShape(s);
  if(c.type==='free'){ c.points = c.points.map(p=>({x:p.x*factor, y:p.y*factor})); }
  else if(c.type==='text'){ c.x*=factor; c.y*=factor; c.size = (c.size||16)*factor; }
  else if(c.type==='icon'){ c.startX*=factor; c.startY*=factor; c.size = (c.size||24)*factor; }
  else {
    c.startX*=factor; c.startY*=factor; c.endX = (c.endX||c.startX)*factor; c.endY = (c.endY||c.startY)*factor;
  }
  c.stroke = (c.stroke||3)*factor;
  if(c.rotation) c.rotation = c.rotation; // keep rotation unchanged
  return c;
}

function scaleShapeAroundCenter(target, original, cx, cy, sx, sy){
  const uni = Math.max(0.05, Math.min(5, Math.max(Math.abs(sx), Math.abs(sy))));
  const applyPoint = (px, py)=>({x: cx + (px - cx) * sx, y: cy + (py - cy) * sy});
  Object.assign(target, cloneShape(original));
  if(target.type==='free'){
    target.points = original.points.map(p=> applyPoint(p.x, p.y));
  } else if(target.type==='text'){
    const p = applyPoint(original.x, original.y);
    target.x = p.x; target.y = p.y; target.size = (original.size||16) * uni;
  } else if(target.type==='icon'){
    const p = applyPoint(original.startX, original.startY);
    target.startX = p.x; target.startY = p.y; target.size = (original.size||24) * uni;
  } else {
    const p1 = applyPoint(original.startX, original.startY);
    const p2 = applyPoint(original.endX||original.startX, original.endY||original.startY);
    target.startX = p1.x; target.startY = p1.y; target.endX = p2.x; target.endY = p2.y;
  }
  target.stroke = (original.stroke||3) * uni;
  target.rotation = original.rotation || 0;
}

  document.getElementById('btnUndo').onclick = ()=>{ shapes.pop(); redrawAnnotations(); };
  document.getElementById('btnClear').onclick = ()=>{ if(confirm('Clear all annotations?')){ shapes=[]; redrawAnnotations(); } };

  document.getElementById('btnExport').onclick = async ()=>{
    if(!pdfDoc) return alert('Load a PDF first');
    try{
      const page = await pdfDoc.getPage(curPage);
      // render at a higher scale for quality
      const desiredScale = Math.min(2, Math.max(1, Math.floor( (window.devicePixelRatio||1) * 1 )));
      const vp = page.getViewport({scale: desiredScale * (pageViewport.scale || 1)});
      const off = document.createElement('canvas'); off.width = Math.ceil(vp.width); off.height = Math.ceil(vp.height);
      const offCtx = off.getContext('2d');
      await page.render({canvasContext:offCtx, viewport:vp}).promise;
      // draw annotations scaled
      const scaleFactor = off.width / canvas.width;
      // draw each shape scaled
      offCtx.strokeStyle='#f00';
      for(const s of shapes){
        const scaled = scaleShape(s, scaleFactor);
        drawShape(offCtx, scaled, 1, false);
      }
      // export as PDF using pdf-lib
      const blob = await new Promise(r=> off.toBlob(r, 'image/jpeg', 0.95));
      const bytes = await blob.arrayBuffer(); const pdflib = window.PDFLib; const newPdf = await pdflib.PDFDocument.create(); const img = await newPdf.embedJpg(bytes); const p = newPdf.addPage([img.width,img.height]); p.drawImage(img,{x:0,y:0,width:img.width,height:img.height}); const pdfBytesOut = await newPdf.save(); const blobOut = new Blob([pdfBytesOut], {type:'application/pdf'}); const url = URL.createObjectURL(blobOut); const a = document.createElement('a'); a.href=url; a.download = `annot_page_${curPage}.pdf`; a.textContent='Download annotated PDF'; a.style.display='block'; out.innerHTML=''; out.appendChild(a);
    }catch(e){ out.textContent='Export failed: '+e.message; console.error(e); }
  };

  // Save as plan: upload generated PDF to /api/upload_plan.php
  document.getElementById('btnSavePlan').onclick = async ()=>{
    try{
      // trigger export first
      const page = await pdfDoc.getPage(curPage);
      const vp = page.getViewport({scale:1.5 * (pageViewport.scale || 1)});
      const off = document.createElement('canvas'); off.width=Math.ceil(vp.width); off.height=Math.ceil(vp.height); const offCtx = off.getContext('2d'); await page.render({canvasContext:offCtx, viewport:vp}).promise;
      const scaleFactor = off.width / canvas.width;
      for(const s of shapes){
        const scaled = scaleShape(s, scaleFactor);
        drawShape(offCtx, scaled, 1, false);
      }
      const blob = await new Promise(r=> off.toBlob(r, 'image/jpeg', 0.95)); const bytes = await blob.arrayBuffer(); const pdflib = window.PDFLib; const newPdf = await pdflib.PDFDocument.create(); const img = await newPdf.embedJpg(bytes); const p2 = newPdf.addPage([img.width,img.height]); p2.drawImage(img,{x:0,y:0,width:img.width,height:img.height}); const pdfBytesOut = await newPdf.save(); const blobOut = new Blob([pdfBytesOut],{type:'application/pdf'});
      // upload using FormData to upload_plan.php
      const fd = new FormData(); fd.append('file', blobOut, 'annotated.pdf'); fd.append('name','Annotated plan');
      const res = await fetch('/api/upload_plan.php',{method:'POST', body:fd}); const txt = await res.text(); const j = JSON.parse(txt);
      if(!res.ok || !j.ok) throw new Error(j.error||'Upload failed'); out.innerHTML = `Saved as plan: <a href='/?plan_id=${j.plan.id}'>${j.plan.name} (#${j.plan.id})</a>`; try{ if(window.refreshPlans) window.refreshPlans(); }catch(e){}
    }catch(e){ out.textContent='Save failed: '+e.message; console.error(e); }
  };

  // open via pdf_url param
  (async function(){ const params=new URLSearchParams(window.location.search); const pdfUrl=params.get('pdf_url'); if(pdfUrl){ showAnnotLoader(); try{ const r=await fetch(pdfUrl); if(!r.ok) return; const ab=await r.arrayBuffer(); await openPdfFromBytes(ab);}catch(e){ console.warn('pdf_url load failed',e);} finally{ hideAnnotLoader(); } } })();

  loadPlans();
  // init static icon select
  try{ initCustomSelect(document.getElementById('iconSelect')); }catch(e){}
</script>
</body>
</html>



