<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CAD Simple Viewer Example</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #f5f5f5;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .file-input-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: none;
        transition: all 0.3s ease;
      }
      
      .file-input-container.loaded {
        top: 2rem;
        left: 2rem;
        transform: none;
      }
      
      .file-fab {
        pointer-events: auto;
        background: #23272f;
        color: #e0e0e0;
        border: none;
        border-radius: 12px;
        width: 80px;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.18);
        cursor: pointer;
        transition: all 0.3s ease;
        outline: none;
        padding: 0;
        position: relative;
      }
      
      .file-input-container.loaded .file-fab {
        width: 40px;
        height: 32px;
      }
      
      .file-fab:hover {
        background: #353b45;
        box-shadow: 0 4px 16px rgba(0,0,0,0.22);
      }
      .file-fab input[type="file"] {
        /* keep input accessible but visually hidden and covering the button so clicks open file picker reliably */
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: pointer;
      }
      .file-fab-label {
        margin-top: 0.5rem;
        color: #fff;
        font-size: 1.2rem;
        text-align: center;
        text-shadow: 0 1px 4px rgba(0,0,0,0.18);
        transition: all 0.3s ease;
      }
      
      .file-input-container.loaded .file-fab-label {
        font-size: 1rem;
      }
      
      .file-icon {
        transition: all 0.3s ease;
      }
      
      .file-input-container.loaded .file-icon {
        width: 20px;
        height: 20px;
      }
      
      .file-fab svg {
        display: block;
        margin: 0 auto;
      }
      
      .button-group {
        display: flex;
        gap: 1.5rem;
        align-items: center;
      }
      
      .file-input-container.loaded .button-group {
        gap: 1rem;
      }
      
      .button-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      
      .file-input-container.hide {
        display: none;
      }

      .viewer-container {
        flex: 1;
        position: relative;
        background: #2c2c2c;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
      }

      #cad-container {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
    <script>
      // Dynamic module loader: try a fixed local copy first, then fallback to the original bundle.
      // Import a dedicated loader module which handles robust import/repair
      (async function(){
        try{
          await import('./dwgviewer-loader.js?t=' + Date.now());
          console.log('dwgviewer-loader imported successfully');
        }catch(err){
          console.error('Failed to import dwgviewer-loader.js', err);
          alert('DWG viewer failed to initialize (see console).');
        }
      })();

      // Message listener for loading files from other windows
      window.addEventListener('message', async (event) => {
        if (event.origin !== window.location.origin) return; // Security check
        if (event.data && event.data.type === 'loadFile') {
          const { file, filename } = event.data;
          try {
            if (window.AcApDocManager && window.AcApDocManager.instance) {
              await window.AcApDocManager.instance.openDocument(filename, file, { minimumChunkSize: 1000, readOnly: true, mouseControls: false });
            } else {
              throw new Error('Viewer not initialized');
            }
            // Hide UI after successful load
            const fileInputContainer = document.getElementById('fileInputContainer');
            if (fileInputContainer) {
              fileInputContainer.classList.add('loaded');
            }
            // Hide new drawing button
            const newDrawingButton = document.getElementById('newDrawingButton');
            if (newDrawingButton) {
              newDrawingButton.style.display = 'none';
            }
            const newButtonLabel = newDrawingButton?.parentElement?.querySelector('.file-fab-label');
            if (newButtonLabel) {
              newButtonLabel.style.display = 'none';
            }
          } catch (err) {
            console.error('Load file failed', err);
            alert('Load file failed: ' + (err && err.message ? err.message : err));
          }
        }
      });
    </script>
  </head>
  <body>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
      <button onclick="window.location.href='/'" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Back to Home</button>
    </div>
    <div class="viewer-container">
      <div class="file-input-container" id="fileInputContainer">
        <div class="button-group">
          <div class="button-container">
            <label class="file-fab" id="fileFab">
              <input type="file" id="fileInputElement" accept=".dxf,.dwg" />
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M3 6.5V15a1.5 1.5 0 0 0 1.5 1.5h11A1.5 1.5 0 0 0 17 15V7.5A1.5 1.5 0 0 0 15.5 6H7.414a1.5 1.5 0 0 1-1.06-.44l-1.414-1.414A1.5 1.5 0 0 0 4.586 4H4.5A1.5 1.5 0 0 0 3 5.5V6.5z"/>
                <path d="M8 11v2m0 0v-2m0 2h4m-4 0h4"/>
              </svg>
            </label>
            <div class="file-fab-label">Open</div>
          </div>
          <div class="button-container">
            <button class="file-fab" id="newDrawingButton">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M10 3v14M3 10h14"/>
              </svg>
            </button>
            <div class="file-fab-label">New</div>
          </div>

          <div class="button-container">
            <button class="file-fab" id="loadSampleBtn" title="Load sample DWG">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M4 7h12M4 11h8M4 15h8" />
              </svg>
            </button>
            <div class="file-fab-label">Sample</div>
          </div>

          <div class="button-container">
            <button class="file-fab" id="exportPdfBtn" title="Export to PDF">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3" />
              </svg>
            </button>
            <div class="file-fab-label">PDF</div>
          </div>
        </div>
      </div>
      <div id="cad-container"></div>
    </div>

    <script>
      // Ensure the file fab forwards clicks to the hidden file input (defensive)
      document.addEventListener('DOMContentLoaded', ()=>{
        // Removed redundant click handler to prevent double file dialog

        // Sample loader button (convenience for debugging / testing)
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        if(loadSampleBtn){
          const findLabel = ()=>{
            // label sits adjacent to the button in markup
            const parent = loadSampleBtn.parentElement;
            if(!parent) return null;
            return parent.querySelector('.file-fab-label');
          };

          loadSampleBtn.addEventListener('click', async (e)=>{
            const label = findLabel();
            const prevLabel = label && label.textContent;
            loadSampleBtn.disabled = true;
            if(label) label.textContent = 'Loading...';
            try{
              // Load sample DWG from CDN
              const response = await fetch('https://cdn.jsdelivr.net/gh/mlightcad/cad-data@main/samples/arc_2000.dwg');
              if (!response.ok) throw new Error('Failed to fetch sample');
              const arrayBuffer = await response.arrayBuffer();
              // Use AcApDocManager like in loadFile
              if (window.AcApDocManager && window.AcApDocManager.instance) {
                await window.AcApDocManager.instance.openDocument('arc_2000.dwg', arrayBuffer, { minimumChunkSize: 1000, readOnly: true, mouseControls: false });
              } else {
                throw new Error('Viewer not initialized');
              }
              // Hide UI after successful load
              const fileInputContainer = document.getElementById('fileInputContainer');
              if (fileInputContainer) {
                fileInputContainer.classList.add('loaded');
              }
              // Hide new drawing button
              const newDrawingButton = document.getElementById('newDrawingButton');
              if (newDrawingButton) {
                newDrawingButton.style.display = 'none';
              }
              const newButtonLabel = newDrawingButton?.parentElement?.querySelector('.file-fab-label');
              if (newButtonLabel) {
                newButtonLabel.style.display = 'none';
              }
            }catch(err){
              console.error('Sample load failed', err);
              alert('Sample load failed: ' + (err && err.message ? err.message : err));
            }finally{
              loadSampleBtn.disabled = false;
              if(label) label.textContent = prevLabel || 'Sample';
            }
          });
        }
      });
    <script>
      // PDF Export functionality
      document.addEventListener('DOMContentLoaded', () => {
        const exportPdfBtn = document.getElementById('exportPdfBtn');
        if (exportPdfBtn) {
          exportPdfBtn.addEventListener('click', async () => {
            const canvas = document.querySelector('#cad-container canvas');
            if (!canvas) {
              alert('No drawing loaded. Please load a DWG file first.');
              return;
            }
            exportPdfBtn.disabled = true;
            try {
              // Ensure jsPDF is available (we only need jsPDF for PDF generation)
              if (!window.jspdf) {
                await new Promise((resolve, reject) => {
                  const script = document.createElement('script');
                  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                  script.onload = resolve;
                  script.onerror = () => reject(new Error('Failed to load jsPDF from CDN'));
                  document.head.appendChild(script);
                });
              }

              // Try direct canvas export first (fastest and preserves fidelity if possible)
              let imgData = null;
              try {
                imgData = canvas.toDataURL('image/png');
                if (!imgData || !imgData.startsWith('data:image')) imgData = null;
              } catch (e) {
                console.warn('canvas.toDataURL failed:', e);
                imgData = null;
              }

              // If direct toDataURL failed or produced no data, attempt WebGL readPixels
              if (!imgData) {
                try {
                  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                  if (gl) {
                    const width = canvas.width;
                    const height = canvas.height;
                    const pixels = new Uint8Array(width * height * 4);
                    // Read the current framebuffer
                    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                    // Flip Y and copy into ImageData
                    const flipped = new Uint8ClampedArray(width * height * 4);
                    for (let y = 0; y < height; y++) {
                      const srcStart = (height - 1 - y) * width * 4;
                      const dstStart = y * width * 4;
                      flipped.set(pixels.subarray(srcStart, srcStart + width * 4), dstStart);
                    }
                    const tmp = document.createElement('canvas');
                    tmp.width = width;
                    tmp.height = height;
                    const ctx = tmp.getContext('2d');
                    const imageData = new ImageData(flipped, width, height);
                    ctx.putImageData(imageData, 0, 0);
                    imgData = tmp.toDataURL('image/png');
                  }
                } catch (e) {
                  console.warn('WebGL readPixels export failed:', e);
                }
              }

              // If still no image data, try html2canvas as a last resort
              if (!imgData) {
                // Load html2canvas on demand
                if (!window.html2canvas) {
                  await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                    script.onload = resolve;
                    script.onerror = () => reject(new Error('Failed to load html2canvas from CDN'));
                    document.head.appendChild(script);
                  });
                }
                const canvasImage = await html2canvas(canvas, { useCORS: true, allowTaint: false });
                imgData = canvasImage.toDataURL('image/png');
              }

              if (!imgData) throw new Error('Unable to capture drawing image. The viewer may be using cross-origin textures or non-readable WebGL state.');

              // Generate PDF using jsPDF
              const { jsPDF } = window.jspdf;
              const pdf = new jsPDF({ unit: 'mm', format: 'a4' });
              const img = new Image();
              img.src = imgData;
              await new Promise((resolve) => { img.onload = resolve; });

              // Fit image to A4 while maintaining aspect ratio
              const pageWidth = 210; // mm
              const pageHeight = 297; // mm
              const pxPerMm = img.width / (img.width / (img.width / (img.height / (img.width / img.width))));
              // Compute scale in mm using image pixel dimensions and a sensible DPI assumption (we'll map pixels to mm by width proportion)
              const imgAspect = img.width / img.height;
              let drawWidth = pageWidth;
              let drawHeight = drawWidth / imgAspect;
              if (drawHeight > pageHeight) {
                drawHeight = pageHeight;
                drawWidth = drawHeight * imgAspect;
              }

              pdf.addImage(imgData, 'PNG', (pageWidth - drawWidth) / 2, (pageHeight - drawHeight) / 2, drawWidth, drawHeight);
              pdf.save('drawing.pdf');
            } catch (error) {
              console.error('PDF export failed', error);
              alert('PDF export failed: ' + (error && error.message ? error.message : error));
            } finally {
              exportPdfBtn.disabled = false;
            }
          });
        }
      });
    </script>
    <script>
      // Add pan and zoom functionality after viewer loads
      const addPanZoom = () => {
        console.log('addPanZoom called');
        const element = document.querySelector('#cad-container canvas');
        if (!element) {
          setTimeout(addPanZoom, 500);
          return;
        }
        console.log('Canvas found:', element);
        console.log('AcApDocManager at setup:', window.AcApDocManager);
        console.log('instance at setup:', window.AcApDocManager?.instance);
        console.log('window.curView:', window.curView);
        console.log('window.curDocument:', window.curDocument);
        console.log('window.viewer:', window.viewer);
        console.log('window keys with view/doc/cad/three:', Object.keys(window).filter(k => /view|doc|cad|three/i.test(k)));
        console.log('element.__renderer:', element.__renderer);
        console.log('element.__scene:', element.__scene);
        console.log('element.__camera:', element.__camera);
        console.log('window.__THREE__:', window.__THREE__);
        let renderer, scene, camera;
        if (window.THREE && window.THREE.WebGLRenderer) {
          const instances = window.THREE.WebGLRenderer.instances || [];
          console.log('WebGLRenderer instances:', instances);
          for (const r of instances) {
            if (r.domElement === element) {
              renderer = r;
              scene = r.scene;
              camera = r.camera;
              break;
            }
          }
        }
        console.log('found renderer:', renderer, 'scene:', scene, 'camera:', camera);
        let isPanning = false;
        let startX, startY;
        // Mouse pan
        element.addEventListener('mousedown', (e) => {
          isPanning = true;
          startX = e.clientX;
          startY = e.clientY;
          element.style.cursor = 'grabbing';
        document.addEventListener('mousemove', (e) => {
          console.log('mousemove', e.clientX, e.clientY);
          console.log('isPanning:', isPanning);
          if (isPanning && camera) {
            const dx = (e.clientX - startX) * 0.01;
            const dy = (e.clientY - startY) * 0.01;
            camera.position.x -= dx;
            camera.position.y += dy;
            if (renderer && scene) renderer.render(scene, camera);
            startX = e.clientX;
            startY = e.clientY;
          }
        });
        document.addEventListener('mouseup', () => {
          isPanning = false;
          element.style.cursor = 'grab';
        });
        element.style.cursor = 'grab';
        // Mouse wheel zoom
        element.addEventListener('wheel', (e) => {
          e.preventDefault();
          if (camera) {
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom *= zoomFactor;
            camera.updateProjectionMatrix();
            if (renderer && scene) renderer.render(scene, camera);
          }
        }, { passive: false });
        // Touch pan and pinch zoom
        let touchStartX, touchStartY;
        let initialDist = 0;
        let prevDist = 0;
        element.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            isPanning = true;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          } else if (e.touches.length === 2) {
            isPanning = false; // Disable pan during pinch
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
            prevDist = initialDist;
          }
        }, { passive: false });
        element.addEventListener('touchmove', (e) => {
          if (e.touches.length === 1 && isPanning && camera) {
            const dx = (e.touches[0].clientX - touchStartX) * 0.01;
            const dy = (e.touches[0].clientY - touchStartY) * 0.01;
            camera.position.x -= dx;
            camera.position.y += dy;
            if (renderer && scene) renderer.render(scene, camera);
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          } else if (e.touches.length === 2 && camera) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const newDist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
            if (prevDist > 0) {
              const zoomFactor = newDist / prevDist;
              camera.zoom *= zoomFactor;
              camera.updateProjectionMatrix();
              if (renderer && scene) renderer.render(scene, camera);
              prevDist = newDist;
            }
          }
        }, { passive: false });
        element.addEventListener('touchend', (e) => {
          if (e.touches.length === 0) {
            isPanning = false;
            initialDist = 0;
            prevDist = 0;
          }
        });
      };
      // Wait for viewer to load then add pan/zoom
      setTimeout(addPanZoom, 2000);
    </script>
  </body>
</html>