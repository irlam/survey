<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CAD Simple Viewer Example</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: #f5f5f5;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .file-input-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        display: flex;
        flex-direction: column;
        align-items: center;
        pointer-events: none;
        transition: all 0.3s ease;
      }
      
      .file-input-container.loaded {
        top: 2rem;
        left: 2rem;
        transform: none;
      }
      
      .file-fab {
        pointer-events: auto;
        background: #23272f;
        color: #e0e0e0;
        border: none;
        border-radius: 12px;
        width: 80px;
        height: 64px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0,0,0,0.18);
        cursor: pointer;
        transition: all 0.3s ease;
        outline: none;
        padding: 0;
        position: relative;
      }
      
      .file-input-container.loaded .file-fab {
        width: 40px;
        height: 32px;
      }
      
      .file-fab:hover {
        background: #353b45;
        box-shadow: 0 4px 16px rgba(0,0,0,0.22);
      }
      .file-fab input[type="file"] {
        /* keep input accessible but visually hidden and covering the button so clicks open file picker reliably */
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        cursor: pointer;
      }
      .file-fab-label {
        margin-top: 0.5rem;
        color: #fff;
        font-size: 1.2rem;
        text-align: center;
        text-shadow: 0 1px 4px rgba(0,0,0,0.18);
        transition: all 0.3s ease;
      }
      
      .file-input-container.loaded .file-fab-label {
        font-size: 1rem;
      }
      
      .file-icon {
        transition: all 0.3s ease;
      }
      
      .file-input-container.loaded .file-icon {
        width: 20px;
        height: 20px;
      }
      
      .file-fab svg {
        display: block;
        margin: 0 auto;
      }
      
      .button-group {
        display: flex;
        gap: 1.5rem;
        align-items: center;
      }
      
      .file-input-container.loaded .button-group {
        gap: 1rem;
      }
      
      .button-container {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      
      .file-input-container.hide {
        display: none;
      }

      .viewer-container {
        flex: 1;
        position: relative;
        background: #2c2c2c;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
      }

      #cad-container {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
    <script>
      // Dynamic module loader: try a fixed local copy first, then fallback to the original bundle.
      // Import a dedicated loader module which handles robust import/repair
      document.addEventListener('DOMContentLoaded', async () => {
        try{
          await import('./dwgviewer-loader.js?t=' + Date.now());
          console.log('dwgviewer-loader imported successfully');

          // Auto-init helper: poll for viewer readiness and try safe initialization heuristics
          (function autoInitViewer(){
            console.log('Auto-init: starting poll for AcApDocManager.instance');
            let attempts = 0;
            const maxAttempts = 60; // ~30s at 500ms interval
            const intervalMs = 500;
            const timer = setInterval(() => {
              attempts++;
              try {
                if (window.AcApDocManager && window.AcApDocManager.instance) {
                  console.log('Auto-init: AcApDocManager.instance is ready (after', attempts, 'attempts)');
                  clearInterval(timer);
                  return;
                }

                // 1) If the repaired bundle exposes a createInstance helper on __dwg_bundle, try that first
                try {
                  const b = window.__dwg_bundle;
                  if (b && typeof b.createInstance === 'function') {
                    console.log('Auto-init: calling __dwg_bundle.createInstance()');
                    try {
                      b.createInstance({ container: document.getElementById('cad-container'), autoResize: true, baseUrl: b.baseUrl || undefined });
                    } catch (e) {
                      console.warn('Auto-init: __dwg_bundle.createInstance threw', e);
                    }
                  }
                } catch (e) { /* ignore */ }

                // 2) Heuristic: look for global constructors whose source contains viewer initialization clues and try to instantiate them
                try {
                  const candidates = [];
                  for (const k of Object.getOwnPropertyNames(window)) {
                    try {
                      const v = window[k];
                      if (typeof v === 'function') {
                        const s = v.toString();
                        if (s && (s.includes('this.container=document.getElementById("cad-container")') || s.includes('initialize(){if(!this.isInitialized)') || s.includes('Failed to initialize CAD viewer'))) {
                          candidates.push(k);
                        }
                      }
                    } catch (e) {}
                  }
                  if (candidates.length) console.log('Auto-init: constructor candidates', candidates.slice(0,10));
                  for (const name of candidates) {
                    try {
                      const C = window[name];
                      const inst = new C();
                      console.log('Auto-init: new ' + name + '() succeeded, instance:', inst);
                      clearInterval(timer);
                      return;
                    } catch (e) {
                      console.warn('Auto-init: new failed for', name, e);
                    }
                  }
                } catch (e) { /* ignore */ }

                if (attempts >= maxAttempts) {
                  console.log('Auto-init: giving up after', attempts, 'attempts');
                  clearInterval(timer);
                }
              } catch (e) {
                console.warn('Auto-init: poll error', e);
              }
            }, intervalMs);
          })();

        }catch(err){
          console.error('Failed to import dwgviewer-loader.js', err);
          alert('DWG viewer failed to initialize (see console).');
        }
      });

      // Message listener for loading files from other windows
      window.addEventListener('message', async (event) => {
        if (event.origin !== window.location.origin) return; // Security check
        if (event.data && event.data.type === 'loadFile') {
          const { file, filename } = event.data;
          try {
            if (window.AcApDocManager && window.AcApDocManager.instance) {
              await window.AcApDocManager.instance.openDocument(filename, file, { minimumChunkSize: 1000, readOnly: true, mouseControls: false });
            } else {
              throw new Error('Viewer not initialized');
            }
            // Hide UI after successful load
            const fileInputContainer = document.getElementById('fileInputContainer');
            if (fileInputContainer) {
              fileInputContainer.classList.add('loaded');
            }
            // Hide new drawing button
            const newDrawingButton = document.getElementById('newDrawingButton');
            if (newDrawingButton) {
              newDrawingButton.style.display = 'none';
            }
            const newButtonLabel = newDrawingButton?.parentElement?.querySelector('.file-fab-label');
            if (newButtonLabel) {
              newButtonLabel.style.display = 'none';
            }
          } catch (err) {
            console.error('Load file failed', err);
            alert('Load file failed: ' + (err && err.message ? err.message : err));
          }
        }
      });
    </script>
  </head>
  <body>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
      <button onclick="window.location.href='/'" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Back to Home</button>
    </div>
    <div class="viewer-container">
      <div class="file-input-container" id="fileInputContainer">
        <div class="button-group">
          <div class="button-container">
            <label class="file-fab" id="fileFab">
              <input type="file" id="fileInputElement" accept=".dxf,.dwg" />
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M3 6.5V15a1.5 1.5 0 0 0 1.5 1.5h11A1.5 1.5 0 0 0 17 15V7.5A1.5 1.5 0 0 0 15.5 6H7.414a1.5 1.5 0 0 1-1.06-.44l-1.414-1.414A1.5 1.5 0 0 0 4.586 4H4.5A1.5 1.5 0 0 0 3 5.5V6.5z"/>
                <path d="M8 11v2m0 0v-2m0 2h4m-4 0h4"/>
              </svg>
            </label>
            <div class="file-fab-label">Open</div>
          </div>
          <div class="button-container">
            <button class="file-fab" id="newDrawingButton">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M10 3v14M3 10h14"/>
              </svg>
            </button>
            <div class="file-fab-label">New</div>
          </div>

          <div class="button-container">
            <button class="file-fab" id="loadSampleBtn" title="Load sample DWG">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M4 7h12M4 11h8M4 15h8" />
              </svg>
            </button>
            <div class="file-fab-label">Sample</div>
          </div>

          <div class="button-container">
            <button class="file-fab" id="initViewerBtn" title="Init viewer (debug)">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M3 6h14M3 10h14M3 14h14" />
              </svg>
            </button>
            <div class="file-fab-label">Init</div>
          </div>

          <div class="button-container">
            <button class="file-fab" id="exportPdfBtn" title="Export to PDF">
              <svg width="40" height="40" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="file-icon">
                <path d="M12 10v6m0 0l-3-3m3 3l3-3" />
              </svg>
            </button>
            <div class="file-fab-label">PDF</div>
          </div>
        </div>
      </div>
      <div id="cad-container"></div>
    </div>

    <script>
      // Ensure the file fab forwards clicks to the hidden file input (defensive)
      document.addEventListener('DOMContentLoaded', ()=>{
        // Removed redundant click handler to prevent double file dialog

        // Sample loader button (convenience for debugging / testing)
        const loadSampleBtn = document.getElementById('loadSampleBtn');
        if(loadSampleBtn){
          const findLabel = ()=>{
            // label sits adjacent to the button in markup
            const parent = loadSampleBtn.parentElement;
            if(!parent) return null;
            return parent.querySelector('.file-fab-label');
          };

          loadSampleBtn.addEventListener('click', async (e)=>{
            const label = findLabel();
            const prevLabel = label && label.textContent;
            loadSampleBtn.disabled = true;
            if(label) label.textContent = 'Loading...';
            try{
              // Load sample DWG from CDN
              const response = await fetch('https://cdn.jsdelivr.net/gh/mlightcad/cad-data@main/samples/arc_2000.dwg');
              if (!response.ok) throw new Error('Failed to fetch sample');
              const arrayBuffer = await response.arrayBuffer();
              // Use AcApDocManager like in loadFile
              if (window.AcApDocManager && window.AcApDocManager.instance) {
                await window.AcApDocManager.instance.openDocument('arc_2000.dwg', arrayBuffer, { minimumChunkSize: 1000, readOnly: true, mouseControls: false });
              } else {
                throw new Error('Viewer not initialized');
              }
              // Hide UI after successful load
              const fileInputContainer = document.getElementById('fileInputContainer');
              if (fileInputContainer) {
                fileInputContainer.classList.add('loaded');
              }
              // Hide new drawing button
              const newDrawingButton = document.getElementById('newDrawingButton');
              if (newDrawingButton) {
                newDrawingButton.style.display = 'none';
              }
              const newButtonLabel = newDrawingButton?.parentElement?.querySelector('.file-fab-label');
              if (newButtonLabel) {
                newButtonLabel.style.display = 'none';
              }
            }catch(err){
              console.error('Sample load failed', err);
              alert('Sample load failed: ' + (err && err.message ? err.message : err));
            }finally{
              loadSampleBtn.disabled = false;
              if(label) label.textContent = prevLabel || 'Sample';
            }
          });
        }

        // Manual Init button (debug): try to find and instantiate a viewer constructor
        const initViewerBtn = document.getElementById('initViewerBtn');
        if (initViewerBtn) {
          initViewerBtn.addEventListener('click', () => {
            try {
              const tryInit = () => {
                const snaps = [];
                for (const k of Object.getOwnPropertyNames(window)) {
                  try {
                    const v = window[k];
                    if (typeof v === 'function') {
                      const s = v.toString();
                      if (s.includes('Failed to initialize CAD viewer') || s.includes('this.container=document.getElementById("cad-container")') || s.includes('initialize(){if(!this.isInitialized)')) {
                        snaps.push(k);
                      }
                    }
                  } catch (e) { /* ignore */ }
                }
                console.log('Init candidates:', snaps);
                for (const name of snaps) {
                  try {
                    const C = window[name];
                    const inst = new C();
                    console.log('Initialized viewer via', name, inst);
                    return true;
                  } catch (e) {
                    console.warn('Init failed for', name, e);
                  }
                }
                return false;
              };
              const ok = tryInit();
              if (!ok) console.log('Init did not find a matching constructor.');
            } catch (e) {
              console.warn('Init click handler error', e);
            }
          });
        }
      });
    </script>
    <script>
      // PDF Export functionality
      async function isImageMostlyBlank(dataUrl){
        return new Promise((resolve)=>{
          const img = new Image();
          img.onload = ()=>{
            try{
              const c = document.createElement('canvas');
              c.width = img.width;
              c.height = img.height;
              const ctx = c.getContext('2d');
              ctx.drawImage(img,0,0);
              const stepX = Math.max(1, Math.floor(img.width / 40));
              const stepY = Math.max(1, Math.floor(img.height / 40));
              let sum=0, sumSq=0, count=0;
              const data = ctx.getImageData(0,0,img.width,img.height).data;
              for(let y=0;y<img.height;y+=stepY){
                for(let x=0;x<img.width;x+=stepX){
                  const idx = (y*img.width + x) * 4;
                  const r = data[idx];
                  const g = data[idx+1];
                  const b = data[idx+2];
                  const a = data[idx+3];
                  const brightness = a === 0 ? 255 : (r+g+b)/3;
                  sum += brightness;
                  sumSq += brightness*brightness;
                  count++;
                }
              }
              const avg = sum / Math.max(1,count);
              const variance = (sumSq / Math.max(1,count)) - (avg*avg);
              const stdDev = Math.sqrt(Math.max(0, variance));
              resolve(avg > 250 && stdDev < 4);
            }catch(err){
              console.warn('isImageMostlyBlank failed', err);
              resolve(false);
            }
          };
          img.onerror = ()=> resolve(false);
          img.src = dataUrl;
        });
      }

      const ensureScript = (url, checkFn) => new Promise((resolve,reject)=>{
        if(checkFn && checkFn()) return resolve();
        const s = document.createElement('script');
        s.src = url;
        s.onload = resolve;
        s.onerror = ()=> reject(new Error('Failed to load '+url));
        document.head.appendChild(s);
      });

      document.addEventListener('DOMContentLoaded', () => {
        const exportPdfBtn = document.getElementById('exportPdfBtn');
        if (exportPdfBtn) {
          exportPdfBtn.addEventListener('click', async () => {
            const canvas = document.querySelector('#cad-container canvas');
            if (!canvas) {
              alert('No drawing loaded. Please load a DWG file first.');
              return;
            }
            exportPdfBtn.disabled = true;
            try {
              // Ensure jsPDF is available (we only need jsPDF for PDF generation)
              await ensureScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js', ()=> window.jspdf);

              // Try direct canvas export first (fastest and preserves fidelity if possible)
              let imgData = null;
              try {
                imgData = canvas.toDataURL('image/png');
                if (!imgData || !imgData.startsWith('data:image')) imgData = null;
                if (imgData && await isImageMostlyBlank(imgData)) {
                  console.warn('PDF export: canvas toDataURL appears blank, will fallback');
                  imgData = null;
                }
              } catch (e) {
                console.warn('canvas.toDataURL failed:', e);
                imgData = null;
              }

              // If direct toDataURL failed or produced no data, attempt WebGL readPixels
              if (!imgData) {
                try {
                  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                  if (gl) {
                    const width = canvas.width;
                    const height = canvas.height;
                    const pixels = new Uint8Array(width * height * 4);
                    // Read the current framebuffer
                    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                    // Flip Y and copy into ImageData
                    const flipped = new Uint8ClampedArray(width * height * 4);
                    for (let y = 0; y < height; y++) {
                      const srcStart = (height - 1 - y) * width * 4;
                      const dstStart = y * width * 4;
                      flipped.set(pixels.subarray(srcStart, srcStart + width * 4), dstStart);
                    }
                    const tmp = document.createElement('canvas');
                    tmp.width = width;
                    tmp.height = height;
                    const ctx = tmp.getContext('2d');
                    const imageData = new ImageData(flipped, width, height);
                    ctx.putImageData(imageData, 0, 0);
                    imgData = tmp.toDataURL('image/png');
                    if (imgData && await isImageMostlyBlank(imgData)) {
                      console.warn('PDF export: WebGL readPixels capture appears blank, will fallback');
                      imgData = null;
                    }
                  }
                } catch (e) {
                  console.warn('WebGL readPixels export failed:', e);
                }
              }

              // If still no image data, try html2canvas as a last resort
              if (!imgData) {
                // Load html2canvas on demand
                await ensureScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js', ()=> window.html2canvas);
                const container = document.getElementById('cad-container') || canvas;
                const canvasImage = await html2canvas(container, { useCORS: true, allowTaint: false, backgroundColor:'#ffffff' });
                imgData = canvasImage.toDataURL('image/png');
              }

              if (!imgData) throw new Error('Unable to capture drawing image. The viewer may be using cross-origin textures or non-readable WebGL state.');

              // Diagnostic: ensure imgData looks like an image data URL and not HTML
              if (typeof imgData === 'string' && imgData.trim().startsWith('<')) {
                console.error('PDF export: captured data appears to be HTML (likely an error page). First 300 chars:', imgData.slice(0,300));
                throw new Error('Captured image data is HTML, not an image. See console for details.');
              }

              // Generate PDF using jsPDF
              const { jsPDF } = window.jspdf;
              const pdf = new jsPDF({ unit: 'mm', format: 'a4' });
              const img = new Image();
              img.src = imgData;
              await new Promise((resolve) => { img.onload = resolve; });

              console.log('PDF export: capture method succeeded, image size px', img.width, img.height);

              // Fit image to A4 while maintaining aspect ratio
              const pageWidth = 210; // mm
              const pageHeight = 297; // mm
              const imgAspect = img.width / img.height;
              // Start by fitting to page width, then scale down if height exceeds page
              let drawWidth = pageWidth;
              let drawHeight = drawWidth / imgAspect;
              if (drawHeight > pageHeight) {
                drawHeight = pageHeight;
                drawWidth = drawHeight * imgAspect;
              }

              console.log('PDF export: image px', img.width, img.height, 'draw mm', drawWidth, drawHeight);

              pdf.addImage(imgData, 'PNG', (pageWidth - drawWidth) / 2, (pageHeight - drawHeight) / 2, drawWidth, drawHeight);
              pdf.save('drawing.pdf');
            } catch (error) {
              console.error('PDF export failed', error);
              alert('PDF export failed: ' + (error && error.message ? error.message : error));
            } finally {
              exportPdfBtn.disabled = false;
            }
          });
        }
      });
    </script>
    <script>
      // Add pan and zoom functionality after viewer loads
      const addPanZoom = () => {
        console.log('addPanZoom called');
        const element = document.querySelector('#cad-container canvas');
        if (!element) {
          setTimeout(addPanZoom, 500);
          return;
        }
        console.log('Canvas found:', element);
        console.log('AcApDocManager at setup:', window.AcApDocManager);
        console.log('instance at setup:', window.AcApDocManager?.instance);
        console.log('window.curView:', window.curView);
        console.log('window.curDocument:', window.curDocument);
        console.log('window.viewer:', window.viewer);
        console.log('window keys with view/doc/cad/three:', Object.keys(window).filter(k => /view|doc|cad|three/i.test(k)));
        console.log('element.__renderer:', element.__renderer);
        console.log('element.__scene:', element.__scene);
        console.log('element.__camera:', element.__camera);
        console.log('window.__THREE__:', window.__THREE__);
        let renderer, scene, camera;
        if (window.THREE && window.THREE.WebGLRenderer) {
          const instances = window.THREE.WebGLRenderer.instances || [];
          console.log('WebGLRenderer instances:', instances);
          for (const r of instances) {
            if (r.domElement === element) {
              renderer = r;
              scene = r.scene;
              camera = r.camera;
              break;
            }
          }
        }
        console.log('found renderer:', renderer, 'scene:', scene, 'camera:', camera);
        let isPanning = false;
        let startX, startY;
        // Mouse pan
        element.addEventListener('mousedown', (e) => {
          isPanning = true;
          startX = e.clientX;
          startY = e.clientY;
          element.style.cursor = 'grabbing';
        });
        document.addEventListener('mousemove', (e) => {
          console.log('mousemove', e.clientX, e.clientY);
          console.log('isPanning:', isPanning);
          if (isPanning && camera) {
            const dx = (e.clientX - startX) * 0.01;
            const dy = (e.clientY - startY) * 0.01;
            camera.position.x -= dx;
            camera.position.y += dy;
            if (renderer && scene) renderer.render(scene, camera);
            startX = e.clientX;
            startY = e.clientY;
          }
        });
        document.addEventListener('mouseup', () => {
          isPanning = false;
          element.style.cursor = 'grab';
        });
        element.style.cursor = 'grab';
        // Mouse wheel zoom
        element.addEventListener('wheel', (e) => {
          e.preventDefault();
          if (camera) {
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.zoom *= zoomFactor;
            camera.updateProjectionMatrix();
            if (renderer && scene) renderer.render(scene, camera);
          }
        }, { passive: false });
        // Touch pan and pinch zoom
        let touchStartX, touchStartY;
        let initialDist = 0;
        let prevDist = 0;
        element.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            isPanning = true;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          } else if (e.touches.length === 2) {
            isPanning = false; // Disable pan during pinch
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
            prevDist = initialDist;
          }
        }, { passive: false });
        element.addEventListener('touchmove', (e) => {
          if (e.touches.length === 1 && isPanning && camera) {
            const dx = (e.touches[0].clientX - touchStartX) * 0.01;
            const dy = (e.touches[0].clientY - touchStartY) * 0.01;
            camera.position.x -= dx;
            camera.position.y += dy;
            if (renderer && scene) renderer.render(scene, camera);
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          } else if (e.touches.length === 2 && camera) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            const newDist = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
            if (prevDist > 0) {
              const zoomFactor = newDist / prevDist;
              camera.zoom *= zoomFactor;
              camera.updateProjectionMatrix();
              if (renderer && scene) renderer.render(scene, camera);
              prevDist = newDist;
            }
          }
        }, { passive: false });
        element.addEventListener('touchend', (e) => {
          if (e.touches.length === 0) {
            isPanning = false;
            initialDist = 0;
            prevDist = 0;
          }
        });
      };
      // Wait for viewer to load then add pan/zoom
      setTimeout(addPanZoom, 2000);
    </script>
  </body>
</html>