<!-- File: tools/crop.html - PDF crop tool UI. -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <meta name="mobile-web-app-capable" content="yes" />
<title>Crop PDF Tool</title>
<link rel="stylesheet" href="/assets/ui.css?v=20260204_1">
<style>
  #cropStage{padding:12px}
  #cropCanvas{border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,.2);background:#222}
  .cropOverlay{position:absolute;left:0;top:0;right:0;bottom:0;touch-action:none;}
  button, input, select {
    min-height: 44px;
    min-width: 44px;
    font-size: 1.1em;
    border-radius: 6px;
  }
  button:active, .btn:active, .btnPrimary:active {
    filter: brightness(0.85);
    box-shadow: 0 0 0 2px #0ff inset;
  }
  /* Neon red square selection with handles for better visibility */
  .cropRect{
    position:absolute;
    border:2px solid rgba(255,80,80,0.95);
    background: linear-gradient(180deg, rgba(255,80,80,0.08), rgba(255,80,80,0.03));
    box-shadow: 0 0 18px rgba(255,80,80,0.5), 0 0 64px rgba(255,80,80,0.10) inset;
    border-radius:6px;
    cursor:move;
    overflow:visible;
    z-index:6;
  }
  .cropRect .cropHandle{
    position:absolute;
    width:14px;height:14px;
    background:linear-gradient(180deg,#fff,#ffd6d6);
    border-radius:3px;
    box-shadow:0 0 12px rgba(255,80,80,0.95);
    border:2px solid rgba(0,0,0,0.25);
    transform:translate(-50%,-50%);
    z-index:8;
  }
  .cropRect .sizeLabel{position:absolute;left:8px;top:8px;background:rgba(0,0,0,0.7);color:#fff;padding:4px 6px;border-radius:4px;font-size:12px;box-shadow:0 2px 6px rgba(0,0,0,0.4);z-index:9}
  .cropOverlay .mask{position:absolute;background:rgba(0,0,0,0.55);pointer-events:none;z-index:4}
  .toolsRow{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  /* Make the plan chooser text white for better visibility in this tool */
  #planSelect .selectButton, #planSelect .selectButton .selectedLabel { color: #ffffff !important; text-shadow: 0 1px 0 rgba(0,0,0,0.6); }
  #planSelect .selectList li { color: #ffffff !important; background: rgba(0,0,0,0.18); border: 1px solid rgba(255,255,255,0.03); }
  #planSelect .selectList li:hover{ background: rgba(255,255,255,0.03); color: var(--neon) !important; }
  #planSelect .selectList li[aria-selected='true']{ background: linear-gradient(90deg, var(--neon), var(--neon2)); color:#000000 !important; }
  #planSelect .selectButton::after{ filter: invert(1); }
  
</style>
</head>
<body>
  <header class="topbar">
    <button onclick="history.back()" class="iconBtn">←</button>
    <div class="brand">Crop PDF Tool</div>
    <div style="margin-left:auto" class="muted">Crop a page and export as a new PDF</div>
  </header>

  <main style="padding:14px;">
    <div class="card">
      <div class="toolsRow">
        <label style="flex:1">
          Select plan:
          <div id="planSelect" class="customSelect neonSelect" style="width:100%; min-width:320px;">
            <button type="button" class="selectButton" aria-haspopup="listbox" aria-expanded="false">-- choose plan --</button>
            <ul class="selectList" role="listbox"></ul>
          </div>
        </label>
        <label style="width:230px">Or upload PDF: <input id="fileUploader" type="file" accept="application/pdf" style="min-width:44px;min-height:44px;"></label>
        <label style="width:220px">DPI: <select id="dpiSelect" class="neonSelect small"><option value="150">150</option><option value="300" selected>300</option><option value="600">600</option><option value="1200">1200</option></select></label>
        <label style="width:180px"><input id="vectorCrop" type="checkbox" style="min-width:44px;min-height:44px;"> Vector crop (server)</label>
        <button id="btnLoad" class="btn">Load</button>
      </div>

      <div style="display:flex;gap:12px;align-items:flex-start">
        <div id="cropStage" style="position:relative;flex:1;">
          <div id="canvasWrap" style="position:relative;display:inline-block;">
            <canvas id="cropCanvas"></canvas>
            <div class="cropOverlay" id="overlayArea"></div>
          </div>
        </div>
        <div style="width:320px;">
          <div style="margin-bottom:8px;">
            <label>Page: <input id="pageInput" type="number" min="1" value="1" style="width:80px;min-width:44px;min-height:44px;"></label>
            <button id="btnPrev" class="btn" style="min-width:44px;min-height:44px;">◀</button>
            <button id="btnNext" class="btn" style="min-width:44px;min-height:44px;">▶</button>
          </div>
          <div style="margin-bottom:8px;">
            <button id="btnCropPreview" class="btn" style="min-width:44px;min-height:44px;">Preview Crop</button>
            <button id="btnExportPdf" class="btnPrimary" style="min-width:44px;min-height:44px;">Export Cropped PDF</button>
          </div>
          <div id="previewOut" class="muted"></div>
        </div>
      </div>
    </div>
  </main>

  <script src="/vendor/pdfjs/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script>
    // Basic crop tool: rasterize a page to canvas, allow drawing a rectangle, extract that rect and embed into new PDF
    const planSelect = document.getElementById('planSelect');
    const fileUploader = document.getElementById('fileUploader');
    const btnLoad = document.getElementById('btnLoad');
    const canvas = document.getElementById('cropCanvas');
    const overlay = document.getElementById('overlayArea');
    const ctx = canvas.getContext('2d');
    let pdfBytes = null; // ArrayBuffer
    let pdfDoc = null; // PDF.js doc
    let curPage = 1;
    let totalPages = 0;
    let scale = 1.0;
    let pageViewport = null;

    pdfjsLib.GlobalWorkerOptions.workerSrc = '/vendor/pdfjs/pdf.worker.min.js';

    document.getElementById('dpiSelect').addEventListener('change', ()=>{ updateDpiInfo(); });

    async function loadPlansList(){
      try{
        const r = await fetch('/api/list_plans.php');
        const j = await r.json();
        planSelect.innerHTML = '<option value="">-- choose plan --</option>';
        if (j.ok && Array.isArray(j.plans)){
          for(const p of j.plans){ const opt = document.createElement('option'); opt.value = p.id; opt.textContent = `${p.name || 'Plan #' + p.id} (#${p.id})`; opt.dataset.file = p.file_path || ''; planSelect.appendChild(opt); }
        }
      }catch(e){ console.warn('Failed to load plans', e); }
    }

    // support loading via ?pdf_url=/storage/exports/xxx.pdf
    (async function(){
      try{
        const params = new URLSearchParams(window.location.search);
        const pdfUrl = params.get('pdf_url');
        if(pdfUrl){
          // show loader
          const loader = document.createElement('span'); loader.className='loader'; loader.id='cropLoader'; loader.style.marginLeft='8px'; document.querySelector('.toolsRow').appendChild(loader);
          // fetch PDF as arraybuffer
          const r = await fetch(pdfUrl, {cache:'no-cache'});
          if(!r.ok) { console.warn('Failed to fetch pdf_url', r.status); loader.remove(); return; }
          const ab = await r.arrayBuffer(); pdfBytes = ab; await openPdfFromBytes(ab); loader.remove();
        }
      }catch(e){ console.warn('pdf_url load failed', e); }
    })();

    planSelect.onchange = async ()=>{
      const id = planSelect.value; if(!id) return;
      const loader = document.createElement('span'); loader.className='loader'; loader.id='cropLoader'; loader.style.marginLeft='8px'; document.querySelector('.toolsRow').appendChild(loader);
      try{
        const res = await fetch('/api/get_plan.php?plan_id=' + encodeURIComponent(id));
        const txt = await res.text(); let j;
        try{ j = JSON.parse(txt); }catch{ throw new Error('Invalid JSON from get_plan'); }
        if(!res.ok || !j.ok) throw new Error(j.error || 'Failed to fetch plan info');
        const pdfUrl = j.pdf_url || (j.plan && (j.plan.file_path ? ('/storage/' + j.plan.file_path) : null));
        if(!pdfUrl) throw new Error('No PDF URL for plan');
        const r2 = await fetch(pdfUrl);
        if(!r2.ok) throw new Error('Failed to fetch PDF: HTTP ' + r2.status);
        const ab = await r2.arrayBuffer(); pdfBytes = ab; await openPdfFromBytes(ab);
      }catch(e){ alert('Failed to fetch plan PDF: '+e.message); document.getElementById('previewOut').textContent = 'Load failed: ' + e.message; console.error(e); } finally { const l = document.getElementById('cropLoader'); if(l) l.remove(); }
    }; 

    fileUploader.onchange = (e)=>{ const f = e.target.files && e.target.files[0]; if(!f) return; const r = new FileReader(); r.onload = async ()=>{ pdfBytes = r.result; // show loader while opening
      const loader = document.getElementById('cropLoader') || (function(){ const l=document.createElement('span'); l.className='loader'; l.id='cropLoader'; l.style.marginLeft='8px'; document.querySelector('.toolsRow').appendChild(l); return l; })();
      try{ await openPdfFromBytes(pdfBytes); }finally{ if(loader) loader.remove(); }
     }; r.readAsArrayBuffer(f); };

    btnLoad.onclick = async ()=>{ if(pdfBytes) { await openPdfFromBytes(pdfBytes); } else if (planSelect.value){ planSelect.onchange(); } else { alert('Select a plan or upload a PDF first'); } };

    async function openPdfFromBytes(ab){
      pdfDoc = await pdfjsLib.getDocument({data: ab}).promise;
      totalPages = pdfDoc.numPages; document.getElementById('pageInput').max = totalPages; document.getElementById('pageInput').value = 1; curPage = 1; await renderPage(curPage);
    }

    async function renderPage(pageNo){ if(!pdfDoc) return; const page = await pdfDoc.getPage(pageNo); const viewport = page.getViewport({scale:1}); const w = Math.min(viewport.width, 1200); scale = w / viewport.width; pageViewport = page.getViewport({scale}); canvas.width = Math.floor(pageViewport.width); canvas.height = Math.floor(pageViewport.height); canvas.style.width = canvas.width + 'px'; canvas.style.height = canvas.height + 'px'; const renderContext = { canvasContext: ctx, viewport: pageViewport }; await page.render(renderContext).promise; updateDpiInfo(); }

    document.getElementById('btnPrev').onclick = async ()=>{ if(curPage>1) { curPage--; document.getElementById('pageInput').value = curPage; await renderPage(curPage); } };
    document.getElementById('btnNext').onclick = async ()=>{ if(curPage<totalPages) { curPage++; document.getElementById('pageInput').value = curPage; await renderPage(curPage); } };
    document.getElementById('pageInput').onchange = async (e)=>{ const v = parseInt(e.target.value||'1',10); if(v>=1 && v<=totalPages){ curPage = v; await renderPage(curPage); } };

    // square selection with resize handles and move support
    let rect = null; // {x,y,w,h} in canvas coords (square: w==h)
    let selectionEl = null;
    let mode = null; // 'drawing' | 'moving' | 'resizing'
    let activeHandle = null;
    let startX=0, startY=0;

    overlay.addEventListener('pointerdown', (e)=>{
      // start drawing a square selection
      const rBounds = canvas.getBoundingClientRect();
      const x = e.clientX - rBounds.left, y = e.clientY - rBounds.top;
      mode = 'drawing'; startX = x; startY = y;
      rect = {x:startX, y:startY, w:0, h:0};
      createOrUpdateSelection();
      overlay.setPointerCapture(e.pointerId);
    });

    overlay.addEventListener('pointermove', (e)=>{
      const rBounds = canvas.getBoundingClientRect();
      const x = e.clientX - rBounds.left, y = e.clientY - rBounds.top;
      if(mode === 'drawing'){
        const dx = x - startX, dy = y - startY;
        const size = Math.max(Math.abs(dx), Math.abs(dy));
        const nx = dx < 0 ? startX - size : startX;
        const ny = dy < 0 ? startY - size : startY;
        rect.x = Math.max(0, Math.min(canvas.width, nx));
        rect.y = Math.max(0, Math.min(canvas.height, ny));
        rect.w = Math.min(size, canvas.width - rect.x);
        rect.h = rect.w;
        createOrUpdateSelection();
      } else if(mode === 'moving' && selectionEl){
        const dx = x - startX, dy = y - startY;
        startX = x; startY = y;
        rect.x = Math.max(0, Math.min(canvas.width - rect.w, rect.x + dx));
        rect.y = Math.max(0, Math.min(canvas.height - rect.h, rect.y + dy));
        updateSelectionElement();
      } else if(mode === 'resizing' && selectionEl && activeHandle){
        const corner = activeHandle.dataset.corner;
        // Determine opposite corner
        const oppX = (corner === 'nw' || corner === 'sw') ? rect.x + rect.w : rect.x;
        const oppY = (corner === 'nw' || corner === 'ne') ? rect.y + rect.h : rect.y;
        const newSize = Math.max(8, Math.min(canvas.width, Math.max(Math.abs(oppX - x), Math.abs(oppY - y))));
        if(corner === 'nw'){ rect.x = Math.max(0, oppX - newSize); rect.y = Math.max(0, oppY - newSize); rect.w = newSize; rect.h = newSize; }
        else if(corner === 'ne'){ rect.x = Math.max(0, oppX - newSize); rect.y = Math.max(0, oppY - newSize); rect.w = newSize; rect.h = newSize; rect.x = oppX - rect.w; }
        else if(corner === 'sw'){ rect.x = Math.max(0, oppX - newSize); rect.y = Math.max(0, oppY - newSize); rect.w = newSize; rect.h = newSize; rect.x = oppX - rect.w; rect.y = oppY - rect.h; }
        else if(corner === 'se'){ rect.w = newSize; rect.h = newSize; if(rect.x + rect.w > canvas.width) rect.x = canvas.width - rect.w; if(rect.y + rect.h > canvas.height) rect.y = canvas.height - rect.h; }
        // constrain
        if(rect.x < 0) rect.x = 0; if(rect.y < 0) rect.y = 0;
        if(rect.x + rect.w > canvas.width) rect.w = canvas.width - rect.x;
        if(rect.y + rect.h > canvas.height) rect.h = canvas.height - rect.y;
        updateSelectionElement();
      }
    });

    overlay.addEventListener('pointerup', (e)=>{
      // If we just finished drawing or resizing, show the preview automatically
      const finishedMode = mode;
      if(mode === 'drawing'){
        if(!rect || rect.w < 6) { rect = null; removeSelection(); }
        else updateSelectionElement();
      }
      // If user finished drawing or resizing and a valid rect exists, show preview
      if((finishedMode === 'drawing' || finishedMode === 'resizing') && rect && rect.w > 6){
        // give UI a tick to settle before generating preview
        setTimeout(()=>{ try{ showPreviewFromRect(rect); }catch(e){ console.warn('Auto-preview failed', e); } }, 8);
      }
      mode = null; activeHandle = null; overlay.releasePointerCapture(e.pointerId); updateDpiInfo();
    });

    function createOrUpdateSelection(){
      if(!selectionEl){
        selectionEl = document.createElement('div'); selectionEl.className='cropRect'; selectionEl.style.position='absolute';
        // add handles
        ['nw','ne','sw','se'].forEach(corner=>{
          const h = document.createElement('div'); h.className='cropHandle'; h.dataset.corner = corner; h.style.position='absolute';
          h.addEventListener('pointerdown', (ev)=>{ ev.stopPropagation(); ev.preventDefault(); mode='resizing'; activeHandle = h; const r = canvas.getBoundingClientRect(); startX = ev.clientX - r.left; startY = ev.clientY - r.top; overlay.setPointerCapture(ev.pointerId); });
          selectionEl.appendChild(h);
        });
        // move handler
        selectionEl.addEventListener('pointerdown', (ev)=>{ ev.stopPropagation(); mode='moving'; const r = canvas.getBoundingClientRect(); startX = ev.clientX - r.left; startY = ev.clientY - r.top; overlay.setPointerCapture(ev.pointerId); });
        // size label
        const label = document.createElement('div'); label.className='sizeLabel'; selectionEl.appendChild(label);
        overlay.appendChild(selectionEl);
      }
      updateSelectionElement();
    }

    function updateSelectionElement(){
      if(!selectionEl || !rect) return;
      selectionEl.style.left = rect.x + 'px'; selectionEl.style.top = rect.y + 'px';
      selectionEl.style.width = rect.w + 'px'; selectionEl.style.height = rect.h + 'px';
      // position handles
      const hw = selectionEl.querySelectorAll('.cropHandle');
      hw.forEach(h=>{
        const c = h.dataset.corner;
        if(c === 'nw') { h.style.left = '0px'; h.style.top = '0px'; }
        if(c === 'ne') { h.style.left = '100%'; h.style.top = '0px'; }
        if(c === 'sw') { h.style.left = '0px'; h.style.top = '100%'; }
        if(c === 'se') { h.style.left = '100%'; h.style.top = '100%'; }
      });
      // update label
      const label = selectionEl.querySelector('.sizeLabel'); if(label){ label.textContent = `${rect.w} × ${rect.h}`; }
      // update global rect var for existing code
      rect = {x: rect.x, y: rect.y, w: rect.w, h: rect.h};
      updateDpiInfo();
    }

    function removeSelection(){ if(selectionEl){ selectionEl.remove(); selectionEl = null; } overlay.innerHTML=''; }

    function updateDpiInfo(){
      const out = document.getElementById('previewOut');
      // If a preview dialog is open, update its meta section instead of clearing the preview
      const previewForm = document.getElementById('previewForm');
      if(previewForm){ const meta = previewForm.querySelector('#previewMeta'); if(!pdfDoc || !rect){ if(meta) meta.textContent = ''; return; } (async ()=>{ try{ const dpi = Number(document.getElementById('dpiSelect').value || '300'); const page = await pdfDoc.getPage(curPage); const desiredScale = dpi / 72; const viewportHR = page.getViewport({scale: desiredScale}); const scaleFactor = viewportHR.width / canvas.width; const rw = Math.max(1, Math.round(Math.abs(rect.w) * scaleFactor)); const rh = Math.max(1, Math.round(Math.abs(rect.h) * scaleFactor)); const kb = Math.round((rw * rh * 3) / 1024); if(meta) meta.innerHTML = `Estimated output: <strong>${rw} × ${rh}</strong> px (~${kb} KB image) at ${dpi} DPI`; if (rw > 8000 || rh > 8000) { if(meta) meta.innerHTML += ` <span style="color:#ffb86b">(Large - may fail or be slow)</span>`; } }catch(e){ console.warn('dpi info error', e); } })(); return; }
      // otherwise update the previewOut area as before
      out.textContent = '';
      if(!pdfDoc || !rect) return;
      (async ()=>{
        try{
          const dpi = Number(document.getElementById('dpiSelect').value || '300');
          const page = await pdfDoc.getPage(curPage);
          const desiredScale = dpi / 72; // PDF points are 72 per inch
          const viewportHR = page.getViewport({scale: desiredScale});
          // map rect (canvas coords) to high-res coordinates
          const scaleFactor = viewportHR.width / canvas.width;
          const rw = Math.max(1, Math.round(Math.abs(rect.w) * scaleFactor));
          const rh = Math.max(1, Math.round(Math.abs(rect.h) * scaleFactor));
          const kb = Math.round((rw * rh * 3) / 1024);
          out.innerHTML = `Estimated output: <strong>${rw} × ${rh}</strong> px (~${kb} KB image) at ${dpi} DPI`;
          // warn if large
          if (rw > 8000 || rh > 8000) {
            out.innerHTML += ` <span style="color:#ffb86b">(Large - may fail or be slow)</span>`;
          }
        }catch(e){ console.warn('dpi info error', e); }
      })();
    }

    function showPreviewFromRect(raw){
      try{
        if(!raw){ alert('Draw a rectangle on the page to crop'); return; }
        const r = {x: Math.max(0, Math.min(raw.x, raw.x+raw.w)), y: Math.max(0, Math.min(raw.y, raw.y+raw.h)), w: Math.round(Math.abs(raw.w)), h: Math.round(Math.abs(raw.h))};
        console.debug('Preview crop rect:', r);
        if (r.w <= 0 || r.h <= 0){ alert('Selected area is too small. Draw a larger rectangle.'); return; }
        if (r.x < 0) r.x = 0; if (r.y < 0) r.y = 0;
        if (r.x + r.w > canvas.width) r.w = canvas.width - r.x;
        if (r.y + r.h > canvas.height) r.h = canvas.height - r.y;
        if (r.w <= 0 || r.h <= 0){ alert('Selected area is out of bounds. Please redraw.'); return; }

        const tmp = document.createElement('canvas'); tmp.width = r.w; tmp.height = r.h;
        const tctx = tmp.getContext('2d');
        tctx.drawImage(canvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);
        const img = tmp.toDataURL('image/jpeg', 0.9);
        const out = document.getElementById('previewOut');
        out.innerHTML = `
          <form id="previewForm" style="margin-top:8px;display:flex;flex-direction:column;gap:8px;">
            <img id="previewImg" src="${img}" style="max-width:100%;border-radius:6px;box-shadow:0 8px 24px rgba(0,0,0,0.6)">
            <div id="previewMeta" class="muted" style="font-size:13px;">Preview: ${r.w} × ${r.h} px — DPI: ${document.getElementById('dpiSelect') ? document.getElementById('dpiSelect').value : '300'}</div>
            <div style="display:flex;gap:8px;">
              <a id="downloadImg" class="btn" href="#">Download JPG</a>
              <button type="button" id="downloadPdf" class="btn">Download PDF</button>
              <button type="button" id="closePreview" class="btn" style="background:rgba(255,255,255,0.04);color:var(--neon);">Close</button>
            </div>
          </form>
        `;
        function dataURLToBlob(dataURL){ const parts = dataURL.split(','); const meta = parts[0]; const bstr = atob(parts[1]); let n = bstr.length; const u8 = new Uint8Array(n); while(n--) u8[n] = bstr.charCodeAt(n); const mime = meta.match(/:(.*?);/)[1]; return new Blob([u8], {type:mime}); }
        try{
          const blob = dataURLToBlob(img);
          const url = URL.createObjectURL(blob);
          const a = document.getElementById('downloadImg'); a.href = url; a.download = `crop_preview_page_${curPage}.jpg`;
          const revokeImgURL = ()=> { try{ URL.revokeObjectURL(url); }catch(e){} };
          a.addEventListener('click', ()=>{ setTimeout(revokeImgURL, 2000); });

          const downloadPdfBtn = document.getElementById('downloadPdf');
          downloadPdfBtn.addEventListener('click', async ()=>{
            try{
              const pdflib = window.PDFLib;
              const newPdf = await pdflib.PDFDocument.create();
              const imgEmbed = await newPdf.embedJpg(await blob.arrayBuffer());
              const pageNew = newPdf.addPage([imgEmbed.width, imgEmbed.height]);
              pageNew.drawImage(imgEmbed, { x:0, y:0, width: imgEmbed.width, height: imgEmbed.height });
              const pdfBytesOut = await newPdf.save();
              const blobOut = new Blob([pdfBytesOut], {type:'application/pdf'});
              const urlPdf = URL.createObjectURL(blobOut);
              const aa = document.createElement('a'); aa.href = urlPdf; aa.download = `crop_preview_page_${curPage}.pdf`; document.body.appendChild(aa); aa.click(); aa.remove(); setTimeout(()=> URL.revokeObjectURL(urlPdf), 3000);
            }catch(e){ alert('Failed to create PDF preview: ' + e.message); console.error(e); }
          });

          document.getElementById('closePreview').addEventListener('click', ()=>{ out.innerHTML = ''; revokeImgURL(); });
        }catch(e){ console.warn('Preview helper setup failed', e); }
      }catch(err){ console.error('Preview crop failed:', err); alert('Preview failed: ' + (err && err.message ? err.message : String(err))); }
    }

    document.getElementById('btnCropPreview').onclick = ()=> showPreviewFromRect(rect);

    document.getElementById('btnExportPdf').onclick = async ()=>{
      if(!rect) { alert('Draw a rectangle on the page to crop'); return; }
      const r = {x: Math.min(rect.x, rect.x+rect.w), y: Math.min(rect.y, rect.y+rect.h), w: Math.abs(rect.w), h: Math.abs(rect.h)};
      const dpi = Number(document.getElementById('dpiSelect').value || '300');
      const isVector = document.getElementById('vectorCrop').checked;
      // If vector crop selected, send normalized rect to server for precise crop
      if(isVector){
        try{
          const payload = new FormData();
          if(planSelect.value){ payload.append('plan_id', planSelect.value); } else if(pdfBytes){ const blobFile = new Blob([pdfBytes], {type:'application/pdf'}); const f = new File([blobFile], 'upload.pdf', {type:'application/pdf'}); payload.append('file', f); }
          payload.append('page', String(curPage));
          // normalized coords (0..1) based on canvas size
          payload.append('x_norm', String(r.x / canvas.width));
          payload.append('y_norm', String(r.y / canvas.height));
          payload.append('w_norm', String(r.w / canvas.width));
          payload.append('h_norm', String(r.h / canvas.height));
          payload.append('debug', '0');
          const out = document.getElementById('previewOut'); out.textContent = 'Requesting server crop…';
          const res = await fetch('/api/crop_pdf.php', { method:'POST', body: payload });
          const txt = await res.text(); let data; try{ data = JSON.parse(txt); }catch{ data = null; }
          if(!res.ok || !data || !data.ok){ throw new Error((data && data.error) ? data.error : 'Server crop failed'); }
          out.innerHTML = `<a href="/storage/exports/${encodeURIComponent(data.filename)}" target="_blank">Download cropped PDF (vector)</a>`;
        }catch(e){ const out = document.getElementById('previewOut'); out.textContent = 'Server crop failed: ' + e.message; }
        return;
      }

      // Raster export at higher resolution (DPI): render an offscreen high-res page and then crop
      try{
        const page = await pdfDoc.getPage(curPage);
        // calculate desired scale for render using DPI: scale = DPI / 72
        const desiredScale = dpi / 72;
        const viewportHR = page.getViewport({scale: desiredScale});
        // Map original rect on screen canvas to high-res canvas
        const scaleFactor = viewportHR.width / canvas.width;
        const rx = Math.round(r.x * scaleFactor);
        const ry = Math.round(r.y * scaleFactor);
        const rw = Math.round(r.w * scaleFactor);
        const rh = Math.round(r.h * scaleFactor);

        // safety caps
        const MAX_PIX = 10000; // avoid OOM
        if (rw > MAX_PIX || rh > MAX_PIX) {
          if (!confirm(`Cropped area is ${rw}×${rh} px at ${dpi} DPI. This may be very large and could fail. Continue?`)) return;
        }

        const off = document.createElement('canvas'); off.width = Math.ceil(viewportHR.width); off.height = Math.ceil(viewportHR.height);
        const offCtx = off.getContext('2d');
        await page.render({ canvasContext: offCtx, viewport: viewportHR }).promise;

        const tmp = document.createElement('canvas'); tmp.width = rw; tmp.height = rh; const tctx = tmp.getContext('2d'); tctx.drawImage(off, rx, ry, rw, rh, 0, 0, rw, rh);
        const blob = await new Promise(res=> tmp.toBlob(res, 'image/jpeg', 0.95));
        const bytes = await blob.arrayBuffer();
        const pdflib = window.PDFLib;
        const newPdf = await pdflib.PDFDocument.create();
        const imgEmbed = await newPdf.embedJpg(bytes);
        const pageNew = newPdf.addPage([imgEmbed.width, imgEmbed.height]);
        pageNew.drawImage(imgEmbed, { x:0, y:0, width: imgEmbed.width, height: imgEmbed.height });
        const pdfBytesOut = await newPdf.save();
        const blobOut = new Blob([pdfBytesOut], {type:'application/pdf'});
        const url = URL.createObjectURL(blobOut);
        const a = document.createElement('a'); a.href = url; a.download = `crop_page_${curPage}.pdf`; a.textContent = 'Download cropped PDF'; a.style.display='inline-block'; a.style.marginTop='8px'; document.getElementById('previewOut').appendChild(a);
      }catch(e){ document.getElementById('previewOut').textContent = 'Export failed: ' + e.message; console.error(e); }
    };

    // init
    // init custom select helper (used for plan picker)
    function selectCustomOption(el, value, label) {
      if (typeof el === 'string') el = document.getElementById(el);
      if (!el) return;
      el.value = value;
      const btn = el.querySelector('.selectButton'); if (btn) btn.textContent = label;
      const items = el.querySelectorAll('li'); items.forEach(li=> li.removeAttribute('aria-selected'));
      const sel = el.querySelector('li[data-value="'+String(value).replace(/"/g,'\"')+'"]'); if (sel) sel.setAttribute('aria-selected','true');
      // fire change event
      el.dispatchEvent(new Event('change'));
    }
    function initCustomSelect(elId){
      const el = document.getElementById(elId); if(!el) return;
      const btn = el.querySelector('.selectButton'); const list = el.querySelector('.selectList');
      const options = list.querySelectorAll('li');
      const first = options[0]; if(first){ el.value = first.dataset.value; btn.textContent = first.textContent; first.setAttribute('aria-selected','true'); }
      btn.addEventListener('click', (e)=>{ e.stopPropagation(); const open = list.classList.toggle('open'); btn.setAttribute('aria-expanded', open? 'true':'false'); });
      list.querySelectorAll('li').forEach(li=> li.addEventListener('click', (e)=>{ e.stopPropagation(); selectCustomOption(el, li.dataset.value, li.textContent); list.classList.remove('open'); btn.setAttribute('aria-expanded','false'); }));
      document.addEventListener('click', (e)=>{ if(!el.contains(e.target)){ list.classList.remove('open'); btn.setAttribute('aria-expanded','false'); } });
    }

    // load plan list and populate custom select
    async function loadPlansList(){
      try{
        const r = await fetch('/api/list_plans.php');
        const j = await r.json();
        const wrapper = document.getElementById('planSelect');
        const list = wrapper.querySelector('.selectList'); list.innerHTML = '';
        // include an empty default option
        const defaultLi = document.createElement('li'); defaultLi.setAttribute('role','option'); defaultLi.dataset.value = ''; defaultLi.textContent = '-- choose plan --'; defaultLi.setAttribute('aria-selected','true'); list.appendChild(defaultLi);
        if (j.ok && Array.isArray(j.plans)){
          for(const p of j.plans){ const li = document.createElement('li'); li.setAttribute('role','option'); li.dataset.value = p.id; li.textContent = `${p.name || 'Plan #' + p.id} (#${p.id})`; li.dataset.file = p.file_path || ''; list.appendChild(li); }
        }
        // re-init event handlers (in case called after DOM ready)
        initCustomSelect('planSelect');
        // handle selection change
        wrapper.addEventListener('change', async ()=>{
          const val = wrapper.value;
          if (!val) return;
          const sel = wrapper.querySelector(`li[data-value="${val}"]`);
          if (!sel) return;
          const planId = val;
          // emulate prior onchange behaviour
          const loader = document.createElement('span'); loader.className='loader'; loader.id='cropLoader'; loader.style.marginLeft='8px'; document.querySelector('.toolsRow').appendChild(loader);
          try{
            const res = await fetch('/api/get_plan.php?plan_id=' + encodeURIComponent(planId));
            const txt = await res.text(); let j2; try{ j2 = JSON.parse(txt); }catch{ throw new Error('Invalid JSON from get_plan'); }
            if(!res.ok || !j2.ok) throw new Error(j2.error || 'Failed to fetch plan info');
            const pdfUrl = j2.pdf_url || (j2.plan && (j2.plan.file_path ? ('/storage/' + j2.plan.file_path) : null));
            if(!pdfUrl) throw new Error('No PDF URL for plan');
            const r2 = await fetch(pdfUrl);
            if(!r2.ok) throw new Error('Failed to fetch PDF: HTTP ' + r2.status);
            const ab = await r2.arrayBuffer(); pdfBytes = ab; await openPdfFromBytes(ab);
          }catch(e){ alert('Failed to fetch plan PDF: '+e.message); document.getElementById('previewOut').textContent = 'Load failed: ' + e.message; console.error(e); } finally { const l = document.getElementById('cropLoader'); if(l) l.remove(); }
        });
      }catch(e){ console.warn('Failed to load plans', e); }
    }

    // init
    loadPlansList();
  </script>
</body>
</html>


